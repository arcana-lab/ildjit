/*
 * Copyright (C) 2009 - 2010 Michele Tartara, Simone Campanoni
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
/**
 * @file optimizer_ddg.c 
 * @brief Plugin for Data Dependency Graph. It does not make use of information from the control flow graph
 */
#include <stdio.h>
#include <assert.h>
#include <errno.h>
#include <ir_optimization_interface.h>
#include <ir_language.h>
#include <iljit-utils.h>
#include <xanlib.h>
#include <compiler_memory_manager.h>

// My headers
#include <optimizer_ddg.h>
#include <config.h>
// End

#define INFORMATIONS 	"This plugin builds the Data Dependency Graph without using information from the control flow graph."
#define	AUTHOR		"Michele Tartara, Simone Campanoni"

static inline JITUINT64 get_job_kind (void);
static inline JITUINT64 get_dependences (void);
static inline void ddg_init (ir_lib_t *lib, ir_optimizer_t *optimizer, char *outputPrefix);
static inline void ddg_shutdown (void);
static inline char * get_version (void);
static inline char * get_informations (void);
static inline char * get_author (void);
static inline void ddg_do_job (ir_method_t *method);
static inline void freePastValues (ir_method_t *method);
static inline JITINT32 internal_isThereDataDependenceAcrossMemory (t_ir_instruction *inst1, t_ir_instruction *inst2);
static inline void internal_add_conservative_dependencies (ir_method_t *method);
static inline JITUINT64 ddg_get_invalidations (void);

void initEscapeUsingInstructions(ir_method_t *method, XanList **escapeUsingOrDefiningInstructions);


/**
 * @brief Plugin interface.
 *
 * Structure storing pointers to the functions used by the plugin as interface.
 */
ir_optimization_interface_t plugin_interface = {
	get_job_kind, 
	get_dependences,
	ddg_init,
	ddg_shutdown,
	ddg_do_job, 
	get_version,
	get_informations,
	get_author,
	ddg_get_invalidations
};

static inline void ddg_shutdown (void){

}

static inline JITUINT64 get_job_kind (void){
	return DDG_COMPUTER;
}

static inline JITUINT64 get_dependences (void){
	return LIVENESS_ANALYZER + ESCAPES_ANALYZER;
}

static inline char * get_version (void){
	return VERSION;
}

static inline char * get_informations (void){
	return INFORMATIONS;
}

static inline char * get_author (void){
	return AUTHOR;
}

static inline void ddg_init (ir_lib_t *lib, ir_optimizer_t *optimizer, char *outputPrefix){

}

/**
 * Data dependencies are calculated without taking into account the Control Flow Graph:
 * an instruction is dependend on another if it uses or defines a variable that the other defines
 */
static inline void ddg_do_job (ir_method_t *method){
	JITUINT32 instructionsNumber;
	JITUINT32 i, j, block;
	JITNUINT def;
	JITNUINT usesBlock;
	JITUINT8 useOffset;
	JITUINT16 depType;
	JITUINT32 instType;
	XanList *escapeUsingOrDefiningInstructions;
	t_ir_instruction *inst, *inst2;
	
	/* Assertions				*/
	assert(method != NULL);
	PDEBUG("OPTIMIZER_DDG: 	Start %s\n", method->getName(method));	

	/* Free old memories			*/
	freePastValues(method);

	/* Initialize some variables	*/
	instructionsNumber 			= IRMETHOD_getInstructionsNumber(method);
	inst 					= NULL;
	escapeUsingOrDefiningInstructions 	= NULL;
	
	/* Can we avoid some work?	*/
	if (instructionsNumber == 0) {
		PDEBUG("OPTIMIZER_DDG: 	There are no instructions: exiting\n");
		return;
	}
	
	if (IRMETHOD_getNumberOfVariablesNeededByMethod(method) == 0) {
		PDEBUG("OPTIMIZER_DDG: 	There are no variables: exiting\n");
		return;
	}
	
	/* Compute the data dependencies by looping through all the instructions */
	for(i=0; i<instructionsNumber; i++) {

		/* Get the instruction							*/
		inst		= IRMETHOD_getInstructionAtPosition(method, i);
		instType 	= inst->type;
	
		/* Check data dependencies generated by the definition of variables 	*/
		def		= livenessGetDef(method, inst);
		if(def == -1){

			/* No variable defined by this instruction: no problems! 		*/
			continue;
		}

		/* A variable is defined: check for data dependencies.			*
		 * Compute the location where the Uses of this variable are registered.	*/
		block 		= def / (sizeof(JITNUINT)*8);
		useOffset 	= def % (sizeof(JITNUINT)*8);
		
		/* Find the instructions where the defined variable is used/defined 	*/
		for(j = 0; j < instructionsNumber; j++) {
				
			/* Get the instruction we are analyzing 				*/
			inst2 	= IRMETHOD_getInstructionAtPosition(method, j);
			assert(inst2 != NULL);

			switch (inst2->type){
				case IRCALL:
				case IRNATIVECALL:
				case IRLIBRARYCALL:
				case IRVCALL:
				case IRICALL:

					/* Everything that uses memory is dependent on call instructions, since they could modify things in memory.	*
					 * Both alias analysis and inter-procedural analysis are required to remove these dependencies. 		*/
					if (IRMETHOD_mayInstructionAccessHeapMemory(method, inst)){ 
						IRMETHOD_addInstructionDataDependence(method, inst, inst2, DEP_MRAW | DEP_MWAR | DEP_MWAW); 
						IRMETHOD_addInstructionDataDependence(method, inst2, inst, DEP_MRAW | DEP_MWAR | DEP_MWAW); 
					}
					break;
				default:

					usesBlock = ir_instr_liveness_use_get(method, inst2, block);
					if ((usesBlock >> useOffset) & 0x1) {

						/* The variable is used: Read After Write Dependency 	*/
						if (instType == IRSTOREREL || instType == IRSTOREELEM || instType == IRINITMEMORY || instType == IRMEMCPY) {

							/* Dependency through memory 				*/
							depType = DEP_MRAW;

						} else {

							/* Dependency through registers				*/
							depType = DEP_RAW;
						}

						/* Add the dependence					*/
						IRMETHOD_addInstructionDataDependence(method, inst2, inst, depType);
					}
					
					if (inst2->liveness.def == def) {

						/* The variable is defined: Write After Write Dependency 	*/
						if (instType == IRSTOREREL || instType == IRSTOREELEM || instType == IRINITMEMORY || instType == IRMEMCPY) {

							/* Dependency through memory 				*/
							depType = DEP_MWAW;

						} else {

							/* Dependency through registers				*/
							depType = DEP_WAW;
						}

						/* Add the dependence						*/
						IRMETHOD_addInstructionDataDependence(method, inst2, inst, depType);
					}
			}
		}
	}

	/* Destroy the lists 			*/
	if(escapeUsingOrDefiningInstructions != NULL) {
		escapeUsingOrDefiningInstructions->destroyListAndData(escapeUsingOrDefiningInstructions);
	}

	/* Add conservative data dependencies	*/
	internal_add_conservative_dependencies(method);

	/* Return		                */
	PDEBUG("OPTIMIZER_DDG: 	End %s\n", method->getName(method));
        return;
}

static inline escapeInfo_t* newEscapeInfo(t_ir_instruction *inst, JITNUINT variableID) {
	escapeInfo_t* escapeInfo;
	
	escapeInfo = allocFunction(sizeof(escapeInfo_t));
	escapeInfo->inst = inst;
	escapeInfo->escapeVariableID = variableID;
	return escapeInfo;
}

static inline JITBOOLEAN isEscapeInfoInList(XanList *list, t_ir_instruction *inst, JITNUINT variableID) {
	XanListItem *listItem;
	escapeInfo_t *escapeInfo;
	
	listItem = list->first(list);
	while(listItem!=NULL) {
		escapeInfo = listItem->data;
		
		if(escapeInfo->inst == inst && escapeInfo->escapeVariableID == variableID) {
			return JITTRUE;
		}
		
		listItem = list->next(list, listItem);
	}
	
	return JITFALSE;
}

/* Initialize the array of escape-using instructions */
void initEscapeUsingInstructions(ir_method_t *method, XanList **eui) {
	JITNUINT *escapeBitmap;
	JITUINT32 last, varNumber;
	JITUINT32 blocksNumber;
	JITUINT32 i, block, nInst;
	JITNUINT thisEscapeBlock, thisUseBlock;
	JITUINT32 instrNum;
	t_ir_instruction *inst;
	XanList *escapeUsingOrDefiningInstructions;
	escapeInfo_t *escapeInfo;
	
	/* Varabiles initialization */
	escapeUsingOrDefiningInstructions = xanListNew(allocFunction, freeFunction, NULL); /**< The list of escaped variables */
	assert (escapeUsingOrDefiningInstructions != NULL);
	*eui = escapeUsingOrDefiningInstructions; //Send the created XanList back to the caller
	escapeBitmap = method->escapesVariables.bitmap; /**< The bitmap representing the escaped variables as computed by the ad-hoc plugin */
	varNumber = IRMETHOD_getNumberOfVariablesNeededByMethod(method);
	blocksNumber = method->escapesVariables.blocksNumber;
	instrNum = IRMETHOD_getInstructionsNumber(method);
	
	for(block=0; block<blocksNumber; block++) {
		if (block==blocksNumber-1) {
			/* Last block: we need just a part of it */
			last= varNumber % (sizeof(method->escapesVariables.bitmap[0])*8);
		} 
		else {
			/* Read all of the block */
			last=sizeof(method->escapesVariables.bitmap[0])*8;
		}
		
		/* Select the current block of the escapes bitvector */
		thisEscapeBlock=escapeBitmap[block];
		
		for(i=0; i<last; i++) {
			if ((thisEscapeBlock >> i) & 0x1) {
				/* The i-th variable is escaped: fetch the instructions that use it and add them to the list */
				for (nInst=0; nInst < instrNum; nInst++) {
					inst = IRMETHOD_getInstructionAtPosition(method, nInst);
					thisUseBlock= ir_instr_liveness_use_get(method, inst, block);
					if (((thisUseBlock >> i) & 0x1 )|| (inst->liveness.def == i)) {
						/* This instruction uses or defines the i-th variable */
						if( ! isEscapeInfoInList(escapeUsingOrDefiningInstructions, inst, i)) {
							escapeInfo = newEscapeInfo(inst, i);
							escapeUsingOrDefiningInstructions->insert(escapeUsingOrDefiningInstructions, escapeInfo);
						}
					}
				}
				
			}
		}
		
	}
}

static inline void freePastValues(ir_method_t *method){
	JITINT32		i;
	JITINT32		instructionsNumber;
	t_ir_instruction	*inst;
	
	/* Assertions			*/
	assert(method != NULL);

	instructionsNumber 	= IRMETHOD_getInstructionsNumber(method);
	for(i=0; i < instructionsNumber; i++) {
		inst	= IRMETHOD_getInstructionAtPosition(method, i);
		if (((inst->data_dependencies).dependingInsts) != NULL){
			((inst->data_dependencies).dependingInsts)->destroyListAndData(((inst->data_dependencies).dependingInsts));
		}
		(inst->data_dependencies).dependingInsts = xanListNew(allocFunction, freeFunction, NULL);
		
		if (((inst->data_dependencies).dependsFrom) != NULL){
			((inst->data_dependencies).dependsFrom)->destroyListAndData(((inst->data_dependencies).dependsFrom));
		}
		(inst->data_dependencies).dependsFrom = xanListNew(allocFunction, freeFunction, NULL);
	}

	/* Return			*/
	return ;
}

static inline JITINT32 internal_isThereDataDependenceAcrossMemory (t_ir_instruction *inst1, t_ir_instruction *inst2){

	if(	((inst2->param_1).type == IROFFSET)						&&
		((inst1->param_1).type == IROFFSET)						){
	
		if (	(IRMETHOD_mayAlias(inst1, inst1->param_1.value, inst2->param_1.value)) 	||
			(IRMETHOD_mayAlias(inst2, inst1->param_1.value, inst2->param_1.value)) 	){
			return JITTRUE;
		}
		return JITFALSE;
	}

	if(	((inst2->param_1).type != IROFFSET)				||
		((inst1->param_1).type != IROFFSET)				){
		
		return ((inst1->param_1).value == (inst2->param_1).value);
	}
	return JITTRUE;
}

static inline void internal_add_conservative_dependencies (ir_method_t *method){
	JITUINT32		i;
	JITUINT32		j;
	JITUINT32		instructionsNumber;
	t_ir_instruction	*inst;
	t_ir_instruction	*inst2;

	/* Fetch the instructions number	*/
	instructionsNumber 	= IRMETHOD_getInstructionsNumber(method);

	for(i=0; i < instructionsNumber; i++) {
		inst		= IRMETHOD_getInstructionAtPosition(method, i);
		for(j=i+1; j < instructionsNumber; j++) {
			inst2		= IRMETHOD_getInstructionAtPosition(method, j);
			if (	(IRMETHOD_mayAccessMemory(method, inst))	&&
				(IRMETHOD_mayAccessMemory(method, inst2))	){
				IRMETHOD_addInstructionDataDependence(method, inst, inst2, DEP_MRAW | DEP_MWAR | DEP_MWAW); 
				IRMETHOD_addInstructionDataDependence(method, inst2, inst, DEP_MRAW | DEP_MWAR | DEP_MWAW); 
			}
		}
	}
	for(i=0; i < instructionsNumber; i++) {
		inst		= IRMETHOD_getInstructionAtPosition(method, i);
		switch(inst->type){
			case IRSTOREREL:
			case IRSTOREELEM:
			case IRINITMEMORY:
			case IRMEMCPY:
				IRMETHOD_addInstructionDataDependence(method, inst, inst, DEP_MWAW);
				break;
		}
	}

	/* Return				*/
	return ;
}

static inline JITUINT64 ddg_get_invalidations (void){
	return INVALIDATE_NONE;
}
