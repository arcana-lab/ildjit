<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>ILDJIT: Bitset</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ildjit_logo_small.jpeg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">ILDJIT
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Bitset<div class="ingroups"><a class="el" href="group___a_p_is.html">APIs</a> &raquo; <a class="el" href="group___xan_lib_doc.html">Data structure API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Bitset:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___xan_bit_set.png" border="0" alt="" usemap="#group______xan__bit__set"/>
<map name="group______xan__bit__set" id="group______xan__bit__set">
<area shape="rect" id="node1" href="group___xan_lib_doc.html" title="Data structures. " alt="" coords="5,5,133,32"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">BitsetThis structure describes a bitset.  <a href="struct_xan_bit_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga38001743c1de8d90812cd8950eb6d9b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38001743c1de8d90812cd8950eb6d9b6"></a>
typedef struct <a class="el" href="struct_xan_bit_set.html">XanBitSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga38001743c1de8d90812cd8950eb6d9b6">XanBitSet</a></td></tr>
<tr class="memdesc:ga38001743c1de8d90812cd8950eb6d9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">BitsetThis structure describes a bitset. <br /></td></tr>
<tr class="separator:ga38001743c1de8d90812cd8950eb6d9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5f1a98a10f68404385c43b92f286892c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga5f1a98a10f68404385c43b92f286892c">xanBitSet_new</a> (size_t length)</td></tr>
<tr class="memdesc:ga5f1a98a10f68404385c43b92f286892c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a bitset structure.Allocates memory for a bitset and returns a pointer to it.  <a href="#ga5f1a98a10f68404385c43b92f286892c">More...</a><br /></td></tr>
<tr class="separator:ga5f1a98a10f68404385c43b92f286892c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f1cb7cab0e4cbd86e6a86093e4feab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga0f1cb7cab0e4cbd86e6a86093e4feab4">xanBitSet_clearAll</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set)</td></tr>
<tr class="memdesc:ga0f1cb7cab0e4cbd86e6a86093e4feab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all bits to 0.Sets all bits in the bitset <code>set</code> to 0.  <a href="#ga0f1cb7cab0e4cbd86e6a86093e4feab4">More...</a><br /></td></tr>
<tr class="separator:ga0f1cb7cab0e4cbd86e6a86093e4feab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebbc42e9d217ab6e3c9b8a3d112bc2d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#gaebbc42e9d217ab6e3c9b8a3d112bc2d0">xanBitSet_setAll</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set)</td></tr>
<tr class="memdesc:gaebbc42e9d217ab6e3c9b8a3d112bc2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all bits to 1.Set all bits in the bitset <code>set</code> to 1.  <a href="#gaebbc42e9d217ab6e3c9b8a3d112bc2d0">More...</a><br /></td></tr>
<tr class="separator:gaebbc42e9d217ab6e3c9b8a3d112bc2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35505f7b47af7963d3f7d2f600f0dcd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga35505f7b47af7963d3f7d2f600f0dcd1">xanBitSet_invertBits</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set)</td></tr>
<tr class="memdesc:ga35505f7b47af7963d3f7d2f600f0dcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert all bits in a bitsetInverts all bits in the bitset <code>set</code> so that bits that were 0 become 1 and bits that were 1 become 0.  <a href="#ga35505f7b47af7963d3f7d2f600f0dcd1">More...</a><br /></td></tr>
<tr class="separator:ga35505f7b47af7963d3f7d2f600f0dcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadac19cbd2979ac6d8152d0c7d7afc177"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#gadac19cbd2979ac6d8152d0c7d7afc177">xanBitSet_subtract</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *fromThis, <a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *subtractThis)</td></tr>
<tr class="memdesc:gadac19cbd2979ac6d8152d0c7d7afc177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract one bitset from another.Subtract bitset <code>subtractThis</code> from bitset <code>fromThis</code>. The result ends up in <code>fromThis</code>, which is modified.  <a href="#gadac19cbd2979ac6d8152d0c7d7afc177">More...</a><br /></td></tr>
<tr class="separator:gadac19cbd2979ac6d8152d0c7d7afc177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6138656576841d554728b6aae9bf8846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga6138656576841d554728b6aae9bf8846">xanBitSet_free</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set)</td></tr>
<tr class="memdesc:ga6138656576841d554728b6aae9bf8846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory used by a bitset.Free memory used by the bitset <code>set</code>.  <a href="#ga6138656576841d554728b6aae9bf8846">More...</a><br /></td></tr>
<tr class="separator:ga6138656576841d554728b6aae9bf8846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab38d518f2f0efc9c90c8338c422f964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#gaab38d518f2f0efc9c90c8338c422f964">xanBitSet_intersect</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *dest, <a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *src)</td></tr>
<tr class="memdesc:gaab38d518f2f0efc9c90c8338c422f964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between two bitsets.Compute the intersection between <code>dest</code> and <code>src</code> and assign it to <code>dest</code>.  <a href="#gaab38d518f2f0efc9c90c8338c422f964">More...</a><br /></td></tr>
<tr class="separator:gaab38d518f2f0efc9c90c8338c422f964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7fc691ce0d2e03125050fdd380588b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga1d7fc691ce0d2e03125050fdd380588b">xanBitSet_union</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *dest, <a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *src)</td></tr>
<tr class="memdesc:ga1d7fc691ce0d2e03125050fdd380588b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the union between two bitsets.Compute the union between <code>dest</code> and <code>src</code> and assign it to <code>dest</code>.  <a href="#ga1d7fc691ce0d2e03125050fdd380588b">More...</a><br /></td></tr>
<tr class="separator:ga1d7fc691ce0d2e03125050fdd380588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga487ab025c74048b209154ee78d2a4130"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga487ab025c74048b209154ee78d2a4130">xanBitSet_getCountOfBitsSet</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set)</td></tr>
<tr class="memdesc:ga487ab025c74048b209154ee78d2a4130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bits set within a bitset.Count the number of bits that are 1 within <code>set</code>.  <a href="#ga487ab025c74048b209154ee78d2a4130">More...</a><br /></td></tr>
<tr class="separator:ga487ab025c74048b209154ee78d2a4130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6566dad8f585db1ccc052d0cb0c056ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga6566dad8f585db1ccc052d0cb0c056ad">xanBitSet_equal</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *bs1, <a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *bs2)</td></tr>
<tr class="memdesc:ga6566dad8f585db1ccc052d0cb0c056ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether two bitsets are equal.Determine whether <code>bs1</code> and <code>bs2</code> have the same length and the same bits set to 1 and 0.  <a href="#ga6566dad8f585db1ccc052d0cb0c056ad">More...</a><br /></td></tr>
<tr class="separator:ga6566dad8f585db1ccc052d0cb0c056ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e928b8763210e108f8f64a0749c656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga06e928b8763210e108f8f64a0749c656">xanBitSet_clone</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *src)</td></tr>
<tr class="memdesc:ga06e928b8763210e108f8f64a0749c656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone a bitset.Clone <code>src</code> and return the newly-created bitset.  <a href="#ga06e928b8763210e108f8f64a0749c656">More...</a><br /></td></tr>
<tr class="separator:ga06e928b8763210e108f8f64a0749c656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa76316a4fbc3bb8fdac72e83dd04f2fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#gaa76316a4fbc3bb8fdac72e83dd04f2fc">xanBitSet_copy</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *dest, <a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *src)</td></tr>
<tr class="memdesc:gaa76316a4fbc3bb8fdac72e83dd04f2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a bitset into another.Copy <code>src</code> into  so that they are equal.  <a href="#gaa76316a4fbc3bb8fdac72e83dd04f2fc">More...</a><br /></td></tr>
<tr class="separator:gaa76316a4fbc3bb8fdac72e83dd04f2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe148702577cdfca07548f41fb0e991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga5fe148702577cdfca07548f41fb0e991">xanBitSet_clearBit</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set, size_t pos)</td></tr>
<tr class="memdesc:ga5fe148702577cdfca07548f41fb0e991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a specific bit within a bitset.Clear the bit at position <code>pos</code> within <code>set</code> (i.e., set it to 0).  <a href="#ga5fe148702577cdfca07548f41fb0e991">More...</a><br /></td></tr>
<tr class="separator:ga5fe148702577cdfca07548f41fb0e991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da4065e4780fa617039972f4f5242e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga4da4065e4780fa617039972f4f5242e8">xanBitSet_setBit</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set, size_t pos)</td></tr>
<tr class="memdesc:ga4da4065e4780fa617039972f4f5242e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a specific bit within a bitset.Set the bit at position <code>pos</code> within <code>set</code> (i.e., set it to 1).  <a href="#ga4da4065e4780fa617039972f4f5242e8">More...</a><br /></td></tr>
<tr class="separator:ga4da4065e4780fa617039972f4f5242e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb59b0db1dccb6956b68f41f0af44541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#gadb59b0db1dccb6956b68f41f0af44541">xanBitSet_setBits</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set, size_t start, size_t end)</td></tr>
<tr class="memdesc:gadb59b0db1dccb6956b68f41f0af44541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set specific bits within a bitset.Set the bits from position <code>start</code> to <code>end</code> inclusive within <code>set</code>.  <a href="#gadb59b0db1dccb6956b68f41f0af44541">More...</a><br /></td></tr>
<tr class="separator:gadb59b0db1dccb6956b68f41f0af44541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f902a3c267a40b99a43d7d1b0de8862"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga4f902a3c267a40b99a43d7d1b0de8862">xanBitSet_isBitSet</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set, size_t pos)</td></tr>
<tr class="memdesc:ga4f902a3c267a40b99a43d7d1b0de8862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a bit is set.Check whether the bit at position <code>pos</code> within <code>set</code> is set (i.e., whether it is 1).  <a href="#ga4f902a3c267a40b99a43d7d1b0de8862">More...</a><br /></td></tr>
<tr class="separator:ga4f902a3c267a40b99a43d7d1b0de8862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b484b8bd1aeec3e27414775b30a5f55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga2b484b8bd1aeec3e27414775b30a5f55">xanBitSet_isSubSetOf</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *setA, <a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *setB)</td></tr>
<tr class="memdesc:ga2b484b8bd1aeec3e27414775b30a5f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether one bitset is a subset of another.Check whether <code>setA</code> is a subset of <code>setB</code>, including them being equal. Both sets must be the same length, otherwise false is returned.  <a href="#ga2b484b8bd1aeec3e27414775b30a5f55">More...</a><br /></td></tr>
<tr class="separator:ga2b484b8bd1aeec3e27414775b30a5f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga616ed4555ba10705db4edbf4e962ee47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga616ed4555ba10705db4edbf4e962ee47">xanBitSet_isIntersectionEmpty</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *setA, <a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *setB)</td></tr>
<tr class="memdesc:ga616ed4555ba10705db4edbf4e962ee47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the intersection of two bitsets is empty.Check whether the intersection of <code>setA</code> and <code>setB</code> is empty.  <a href="#ga616ed4555ba10705db4edbf4e962ee47">More...</a><br /></td></tr>
<tr class="separator:ga616ed4555ba10705db4edbf4e962ee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec3ebceeae325cc8dfcfd7e17687f40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga9ec3ebceeae325cc8dfcfd7e17687f40">xanBitSet_isEmpty</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set)</td></tr>
<tr class="memdesc:ga9ec3ebceeae325cc8dfcfd7e17687f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a bitset is empty.Check whether <code>set</code> is empty. I.e. it has no bits set.  <a href="#ga9ec3ebceeae325cc8dfcfd7e17687f40">More...</a><br /></td></tr>
<tr class="separator:ga9ec3ebceeae325cc8dfcfd7e17687f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1288a014ebd713a24f4df207952ad6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#gaf1288a014ebd713a24f4df207952ad6e">xanBitSet_areEqual</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *setA, <a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *setB)</td></tr>
<tr class="memdesc:gaf1288a014ebd713a24f4df207952ad6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two bitsets are equal.Check whether <code>setA</code> has exactly the same bits set as <code>setB</code>.  <a href="#gaf1288a014ebd713a24f4df207952ad6e">More...</a><br /></td></tr>
<tr class="separator:gaf1288a014ebd713a24f4df207952ad6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91e6bf3f2e17dd87d6409dd2325222e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga91e6bf3f2e17dd87d6409dd2325222e5">xanBitSet_print</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set, int cr)</td></tr>
<tr class="memdesc:ga91e6bf3f2e17dd87d6409dd2325222e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a bitset to stdout.Print <code>set</code> to stdout. Include a new line if  is non-zero.  <a href="#ga91e6bf3f2e17dd87d6409dd2325222e5">More...</a><br /></td></tr>
<tr class="separator:ga91e6bf3f2e17dd87d6409dd2325222e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad288d077a1b4e5e27416cbd3cf520aff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#gad288d077a1b4e5e27416cbd3cf520aff">xanBitSet_getFirstBitSetInRange</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set, size_t start, size_t end)</td></tr>
<tr class="memdesc:gad288d077a1b4e5e27416cbd3cf520aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the position of the first bit set in a bitset between two positions, inclusive.Find the position of the first bit that is set (i.e., 1) in <code>set</code>, starting at <code>start</code> and ending at <code>end</code> inclusive. It is assumed that <code>start</code> will be less than or equal to <code>end</code>.  <a href="#gad288d077a1b4e5e27416cbd3cf520aff">More...</a><br /></td></tr>
<tr class="separator:gad288d077a1b4e5e27416cbd3cf520aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf38ab54a6aee22350dd7a20677c7286c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#gaf38ab54a6aee22350dd7a20677c7286c">xanBitSet_getFirstBitUnsetInRange</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set, size_t start, size_t end)</td></tr>
<tr class="memdesc:gaf38ab54a6aee22350dd7a20677c7286c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the position of the first bit unset in a bitset between two positions, inclusive.Find the position of the first bit that is unset (i.e., 0) in <code>set</code>, starting at <code>start</code> and ending at <code>end</code> inclusive. It is assumed that <code>start</code> will be less than or equal to <code>end</code>.  <a href="#gaf38ab54a6aee22350dd7a20677c7286c">More...</a><br /></td></tr>
<tr class="separator:gaf38ab54a6aee22350dd7a20677c7286c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3437077b6525ddaff2c78addca9c2f6c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga3437077b6525ddaff2c78addca9c2f6c">xanBitSet_length</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set)</td></tr>
<tr class="memdesc:ga3437077b6525ddaff2c78addca9c2f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the bit set (i.e. the number of bits stored).Get the number of bits stored by <code>set</code>.  <a href="#ga3437077b6525ddaff2c78addca9c2f6c">More...</a><br /></td></tr>
<tr class="separator:ga3437077b6525ddaff2c78addca9c2f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3131cde5077d91d9b2bccb7d0b593907"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xan_bit_set.html#ga3131cde5077d91d9b2bccb7d0b593907">xanBitSet_capacity</a> (<a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *set)</td></tr>
<tr class="memdesc:ga3131cde5077d91d9b2bccb7d0b593907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the capacity of the bit set (i.e. the number of bytes allocated).Get the capacity of <code>set</code> in bytes.  <a href="#ga3131cde5077d91d9b2bccb7d0b593907">More...</a><br /></td></tr>
<tr class="separator:ga3131cde5077d91d9b2bccb7d0b593907"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>In order to allocate a bitset of length <code>length</code> we have to write the following lines of code:<br />
</p><div class="fragment"><div class="line"><a class="code" href="struct_xan_bit_set.html">XanBitSet</a> *mySet;</div>
<div class="line">mySet  = <a class="code" href="group___xan_bit_set.html#ga5f1a98a10f68404385c43b92f286892c">xanBitSet_new</a>(length);</div>
</div><!-- fragment --><p> <br />
<br />
In order to set bit <code>n</code>, we have to write the following lines of code:<br />
</p><div class="fragment"><div class="line"><a class="code" href="group___xan_bit_set.html#ga4da4065e4780fa617039972f4f5242e8">xanBitSet_setBit</a>(mySet, n);</div>
</div><!-- fragment --><p> <br />
<br />
In order to check whether a bit <code>n</code> is set, we have to write:<br />
</p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> isSet;</div>
<div class="line">isSet = <a class="code" href="group___xan_bit_set.html#ga4f902a3c267a40b99a43d7d1b0de8862">xanBitSet_isBitSet</a>(mySet, n);</div>
</div><!-- fragment --><p> <br />
<br />
In order to deallocate the bitset, we have to write:<br />
</p><div class="fragment"><div class="line"><a class="code" href="group___xan_bit_set.html#ga6138656576841d554728b6aae9bf8846">xanBitSet_free</a>(mySet);</div>
</div><!-- fragment --><p>Next: <a class="el" href="group___copyright.html">Copyright</a> </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf1288a014ebd713a24f4df207952ad6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xanBitSet_areEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>setA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>setB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether two bitsets are equal.Check whether <code>setA</code> has exactly the same bits set as <code>setB</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setA</td><td>The first bitset to consider. </td></tr>
    <tr><td class="paramname">setB</td><td>The second bitset to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two bitsets are equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3131cde5077d91d9b2bccb7d0b593907"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t xanBitSet_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the capacity of the bit set (i.e. the number of bytes allocated).Get the capacity of <code>set</code> in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to get the capacity of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The capacity of <code>set</code> in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f1cb7cab0e4cbd86e6a86093e4feab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xanBitSet_clearAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all bits to 0.Sets all bits in the bitset <code>set</code> to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5fe148702577cdfca07548f41fb0e991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xanBitSet_clearBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a specific bit within a bitset.Clear the bit at position <code>pos</code> within <code>set</code> (i.e., set it to 0). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to clear a bit in. </td></tr>
    <tr><td class="paramname">pos</td><td>The position of the bit to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga06e928b8763210e108f8f64a0749c656"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a>* xanBitSet_clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone a bitset.Clone <code>src</code> and return the newly-created bitset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The bitset to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created bitset. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa76316a4fbc3bb8fdac72e83dd04f2fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xanBitSet_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a bitset into another.Copy <code>src</code> into  so that they are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The bitset to copy into. </td></tr>
    <tr><td class="paramname">src</td><td>The bitset to copy from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6566dad8f585db1ccc052d0cb0c056ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xanBitSet_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>bs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>bs2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether two bitsets are equal.Determine whether <code>bs1</code> and <code>bs2</code> have the same length and the same bits set to 1 and 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs1</td><td>The first bitset for comparison. </td></tr>
    <tr><td class="paramname">bs2</td><td>The second bitset for comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>bs1</code> and <code>bs2</code> are equal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6138656576841d554728b6aae9bf8846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xanBitSet_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory used by a bitset.Free memory used by the bitset <code>set</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga487ab025c74048b209154ee78d2a4130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xanBitSet_getCountOfBitsSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of bits set within a bitset.Count the number of bits that are 1 within <code>set</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The count of bits set in <code>set</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad288d077a1b4e5e27416cbd3cf520aff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xanBitSet_getFirstBitSetInRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the position of the first bit set in a bitset between two positions, inclusive.Find the position of the first bit that is set (i.e., 1) in <code>set</code>, starting at <code>start</code> and ending at <code>end</code> inclusive. It is assumed that <code>start</code> will be less than or equal to <code>end</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to consider. </td></tr>
    <tr><td class="paramname">start</td><td>The position to start looking. </td></tr>
    <tr><td class="paramname">end</td><td>The position to finish looking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the first bit that is set, or -1 if no bit is set within the range. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf38ab54a6aee22350dd7a20677c7286c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xanBitSet_getFirstBitUnsetInRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the position of the first bit unset in a bitset between two positions, inclusive.Find the position of the first bit that is unset (i.e., 0) in <code>set</code>, starting at <code>start</code> and ending at <code>end</code> inclusive. It is assumed that <code>start</code> will be less than or equal to <code>end</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to consider. </td></tr>
    <tr><td class="paramname">start</td><td>The position to start looking. </td></tr>
    <tr><td class="paramname">end</td><td>The position to finish looking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the first bit that is unset, or -1 if no bit is unset within the range. </dd></dl>

</div>
</div>
<a class="anchor" id="gaab38d518f2f0efc9c90c8338c422f964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xanBitSet_intersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between two bitsets.Compute the intersection between <code>dest</code> and <code>src</code> and assign it to <code>dest</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>One source bitset for the intersection and the destination bitset. </td></tr>
    <tr><td class="paramname">src</td><td>The second source bitset for the intersection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga35505f7b47af7963d3f7d2f600f0dcd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xanBitSet_invertBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert all bits in a bitsetInverts all bits in the bitset <code>set</code> so that bits that were 0 become 1 and bits that were 1 become 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to invert bits in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4f902a3c267a40b99a43d7d1b0de8862"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xanBitSet_isBitSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a bit is set.Check whether the bit at position <code>pos</code> within <code>set</code> is set (i.e., whether it is 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to check within. </td></tr>
    <tr><td class="paramname">pos</td><td>The position of the bit to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the bit at position <code>pos</code> is set, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ec3ebceeae325cc8dfcfd7e17687f40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xanBitSet_isEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a bitset is empty.Check whether <code>set</code> is empty. I.e. it has no bits set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The set to check for being empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>set</code> is empty, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga616ed4555ba10705db4edbf4e962ee47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xanBitSet_isIntersectionEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>setA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>setB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the intersection of two bitsets is empty.Check whether the intersection of <code>setA</code> and <code>setB</code> is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setA</td><td>The first bitset to consider. </td></tr>
    <tr><td class="paramname">setB</td><td>The second bitset to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the intersection of <code>setA</code> and <code>setB</code> is empty, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b484b8bd1aeec3e27414775b30a5f55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xanBitSet_isSubSetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>setA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>setB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether one bitset is a subset of another.Check whether <code>setA</code> is a subset of <code>setB</code>, including them being equal. Both sets must be the same length, otherwise false is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setA</td><td>The bitset to check for being a subset of <code>setB</code>. </td></tr>
    <tr><td class="paramname">setB</td><td>The bitset to check for being a superset of <code>setA</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>setA</code> is a subset of <code>setB</code>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3437077b6525ddaff2c78addca9c2f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t xanBitSet_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the length of the bit set (i.e. the number of bits stored).Get the number of bits stored by <code>set</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to get the length of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bits stored by <code>set</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f1a98a10f68404385c43b92f286892c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a>* xanBitSet_new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a bitset structure.Allocates memory for a bitset and returns a pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The length of the bitset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new bitset. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91e6bf3f2e17dd87d6409dd2325222e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xanBitSet_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a bitset to stdout.Print <code>set</code> to stdout. Include a new line if  is non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to print. </td></tr>
    <tr><td class="paramname">cr</td><td>Whether to add a new line at the end. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebbc42e9d217ab6e3c9b8a3d112bc2d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xanBitSet_setAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all bits to 1.Set all bits in the bitset <code>set</code> to 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to set all bits in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4da4065e4780fa617039972f4f5242e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xanBitSet_setBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a specific bit within a bitset.Set the bit at position <code>pos</code> within <code>set</code> (i.e., set it to 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to set a bit in. </td></tr>
    <tr><td class="paramname">pos</td><td>The position of the bit to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadb59b0db1dccb6956b68f41f0af44541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xanBitSet_setBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set specific bits within a bitset.Set the bits from position <code>start</code> to <code>end</code> inclusive within <code>set</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The bitset to set bits in. </td></tr>
    <tr><td class="paramname">start</td><td>The position of the first bit to set. </td></tr>
    <tr><td class="paramname">end</td><td>The position of the last bit to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadac19cbd2979ac6d8152d0c7d7afc177"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xanBitSet_subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>fromThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>subtractThis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract one bitset from another.Subtract bitset <code>subtractThis</code> from bitset <code>fromThis</code>. The result ends up in <code>fromThis</code>, which is modified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromThis</td><td>The bitset to subtract <code>subtractThis</code> from. </td></tr>
    <tr><td class="paramname">subtractThis</td><td>The bitset to subtract from <code>fromThis</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1d7fc691ce0d2e03125050fdd380588b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xanBitSet_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xan_bit_set.html">XanBitSet</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the union between two bitsets.Compute the union between <code>dest</code> and <code>src</code> and assign it to <code>dest</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>One source bitset for the union and the destination bitset. </td></tr>
    <tr><td class="paramname">src</td><td>The second source bitset for the union. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 30 2014 10:00:57 for ILDJIT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
