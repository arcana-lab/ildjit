<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>ILDJIT: Threads functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ildjit_logo_small.jpeg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">ILDJIT
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Threads functions<div class="ingroups"><a class="el" href="group___a_p_is.html">APIs</a> &raquo; <a class="el" href="group___p_l_a_t_f_o_r_m___a_p_i.html">Platform API</a> &raquo; <a class="el" href="group___t_h_r_e_a_d_s.html">Threads</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Threads functions:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___t_h_r_e_a_d_s___b_a_s_e.png" border="0" alt="" usemap="#group______t__h__r__e__a__d__s______b__a__s__e"/>
<map name="group______t__h__r__e__a__d__s______b__a__s__e" id="group______t__h__r__e__a__d__s______b__a__s__e">
<area shape="rect" id="node1" href="group___t_h_r_e_a_d_s.html" title="Threads" alt="" coords="5,5,75,32"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Threads</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp03bfaee27b3b5cfb28deef84a0f416e5"></a>Functions used to gain platform-indipendent multiple flows of control. </p>
</td></tr>
<tr class="memitem:gaf2fa4004ae226cf350447a6c3b4b9e63"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gaf2fa4004ae226cf350447a6c3b4b9e63">PLATFORM_createThread</a> (pthread_t *arg1, const pthread_attr_t *arg2, void *(*thread_function)(void *), void *arg4)</td></tr>
<tr class="memdesc:gaf2fa4004ae226cf350447a6c3b4b9e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new thread.  <a href="#gaf2fa4004ae226cf350447a6c3b4b9e63">More...</a><br /></td></tr>
<tr class="separator:gaf2fa4004ae226cf350447a6c3b4b9e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e5bf1362c602d7d43ca8467e92db76"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga09e5bf1362c602d7d43ca8467e92db76">PLATFORM_joinThread</a> (pthread_t arg1, void **arg2)</td></tr>
<tr class="memdesc:ga09e5bf1362c602d7d43ca8467e92db76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for thread termination.  <a href="#ga09e5bf1362c602d7d43ca8467e92db76">More...</a><br /></td></tr>
<tr class="separator:ga09e5bf1362c602d7d43ca8467e92db76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a2ba08031740378a202fbeeea4ee378"><td class="memItemLeft" align="right" valign="top">pthread_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga0a2ba08031740378a202fbeeea4ee378">PLATFORM_getSelfThreadID</a> (void)</td></tr>
<tr class="memdesc:ga0a2ba08031740378a202fbeeea4ee378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of the calling thread.  <a href="#ga0a2ba08031740378a202fbeeea4ee378">More...</a><br /></td></tr>
<tr class="separator:ga0a2ba08031740378a202fbeeea4ee378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39518c80bcbdd62282767649e35a2ec7"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga39518c80bcbdd62282767649e35a2ec7">PLATFORM_pthread_once</a> (pthread_once_t *arg1, void(*thread_function)(void))</td></tr>
<tr class="memdesc:ga39518c80bcbdd62282767649e35a2ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic package initialization.  <a href="#ga39518c80bcbdd62282767649e35a2ec7">More...</a><br /></td></tr>
<tr class="separator:ga39518c80bcbdd62282767649e35a2ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5e87e2a6306bc37bd88781ba3e2d73"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gacb5e87e2a6306bc37bd88781ba3e2d73">PLATFORM_equalThread</a> (pthread_t arg1, pthread_t arg2)</td></tr>
<tr class="memdesc:gacb5e87e2a6306bc37bd88781ba3e2d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare thread IDs.  <a href="#gacb5e87e2a6306bc37bd88781ba3e2d73">More...</a><br /></td></tr>
<tr class="separator:gacb5e87e2a6306bc37bd88781ba3e2d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60728cd6aaa9da6816d85bf2fc55cf4a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga60728cd6aaa9da6816d85bf2fc55cf4a">PLATFORM_threadHashFunc</a> (void *element)</td></tr>
<tr class="memdesc:ga60728cd6aaa9da6816d85bf2fc55cf4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute hash function from thread handler.  <a href="#ga60728cd6aaa9da6816d85bf2fc55cf4a">More...</a><br /></td></tr>
<tr class="separator:ga60728cd6aaa9da6816d85bf2fc55cf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99633fd674713b69a6926be43706979b"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga99633fd674713b69a6926be43706979b">PLATFORM_sched_yield</a> (void)</td></tr>
<tr class="memdesc:ga99633fd674713b69a6926be43706979b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yeld schedule.  <a href="#ga99633fd674713b69a6926be43706979b">More...</a><br /></td></tr>
<tr class="separator:ga99633fd674713b69a6926be43706979b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b73a33ac6cff82cb84a09d627e854e"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gaf3b73a33ac6cff82cb84a09d627e854e">PLATFORM_sched_get_priority_max</a> (JITNINT arg1)</td></tr>
<tr class="memdesc:gaf3b73a33ac6cff82cb84a09d627e854e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get priority max limit.  <a href="#gaf3b73a33ac6cff82cb84a09d627e854e">More...</a><br /></td></tr>
<tr class="separator:gaf3b73a33ac6cff82cb84a09d627e854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa074d9567d04d79ca14838b22234ca"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gadaa074d9567d04d79ca14838b22234ca">PLATFORM_sched_get_priority_min</a> (JITNINT arg1)</td></tr>
<tr class="memdesc:gadaa074d9567d04d79ca14838b22234ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get priority min limit.  <a href="#gadaa074d9567d04d79ca14838b22234ca">More...</a><br /></td></tr>
<tr class="separator:gadaa074d9567d04d79ca14838b22234ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c57e7902a9fa1ece3b51cba72aeb6b0"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga7c57e7902a9fa1ece3b51cba72aeb6b0">PLATFORM_initThreadAttr</a> (pthread_attr_t *arg1)</td></tr>
<tr class="memdesc:ga7c57e7902a9fa1ece3b51cba72aeb6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize thread attribute object.  <a href="#ga7c57e7902a9fa1ece3b51cba72aeb6b0">More...</a><br /></td></tr>
<tr class="separator:ga7c57e7902a9fa1ece3b51cba72aeb6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10dac894350cd3531c5ec74cc4614066"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga10dac894350cd3531c5ec74cc4614066">PLATFORM_setThreadAttr_scope</a> (pthread_attr_t *arg1, JITNINT arg2)</td></tr>
<tr class="memdesc:ga10dac894350cd3531c5ec74cc4614066"><td class="mdescLeft">&#160;</td><td class="mdescRight">set scheduling scope attribute.  <a href="#ga10dac894350cd3531c5ec74cc4614066">More...</a><br /></td></tr>
<tr class="separator:ga10dac894350cd3531c5ec74cc4614066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadef31dcc2d43c0ebe50b31648ef40a0e"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gadef31dcc2d43c0ebe50b31648ef40a0e">PLATFORM_setThreadAttr_stackSize</a> (pthread_attr_t *arg1, size_t arg2)</td></tr>
<tr class="memdesc:gadef31dcc2d43c0ebe50b31648ef40a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set thread stack size attribute.  <a href="#gadef31dcc2d43c0ebe50b31648ef40a0e">More...</a><br /></td></tr>
<tr class="separator:gadef31dcc2d43c0ebe50b31648ef40a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga150cc3d61124fc0a8b40cf724d01282e"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga150cc3d61124fc0a8b40cf724d01282e">PLATFORM_setThreadAttr_inheritsched</a> (pthread_attr_t *arg1, JITNINT arg2)</td></tr>
<tr class="memdesc:ga150cc3d61124fc0a8b40cf724d01282e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set scheduling parameter inheritance state attribute.  <a href="#ga150cc3d61124fc0a8b40cf724d01282e">More...</a><br /></td></tr>
<tr class="separator:ga150cc3d61124fc0a8b40cf724d01282e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65143bde61a965df3461b3147efbe580"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga65143bde61a965df3461b3147efbe580">PLATFORM_setThreadAttr_schedparam</a> (pthread_attr_t *arg1, const struct sched_param *arg2)</td></tr>
<tr class="memdesc:ga65143bde61a965df3461b3147efbe580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set scheduling parameter attribute.  <a href="#ga65143bde61a965df3461b3147efbe580">More...</a><br /></td></tr>
<tr class="separator:ga65143bde61a965df3461b3147efbe580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94c0df82573340fc03e3329505ff222"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gae94c0df82573340fc03e3329505ff222">PLATFORM_setThreadAttr_schedpolicy</a> (pthread_attr_t *arg1, JITNINT arg2)</td></tr>
<tr class="memdesc:gae94c0df82573340fc03e3329505ff222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set scheduling policy attribute.  <a href="#gae94c0df82573340fc03e3329505ff222">More...</a><br /></td></tr>
<tr class="separator:gae94c0df82573340fc03e3329505ff222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8c0a9cfc35da8135d3447d739f385bf"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gae8c0a9cfc35da8135d3447d739f385bf">PLATFORM_initMutex</a> (pthread_mutex_t *arg1, const pthread_mutexattr_t *arg2)</td></tr>
<tr class="memdesc:gae8c0a9cfc35da8135d3447d739f385bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a mutex.  <a href="#gae8c0a9cfc35da8135d3447d739f385bf">More...</a><br /></td></tr>
<tr class="separator:gae8c0a9cfc35da8135d3447d739f385bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee60da7a9b3b96ac9927ce51c36b568"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga4ee60da7a9b3b96ac9927ce51c36b568">PLATFORM_initMutexAttr</a> (pthread_mutexattr_t *arg1)</td></tr>
<tr class="memdesc:ga4ee60da7a9b3b96ac9927ce51c36b568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize mutex attribute object.  <a href="#ga4ee60da7a9b3b96ac9927ce51c36b568">More...</a><br /></td></tr>
<tr class="separator:ga4ee60da7a9b3b96ac9927ce51c36b568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f40d295a84a6be7b525ae65ffb42ec2"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga6f40d295a84a6be7b525ae65ffb42ec2">PLATFORM_setMutexAttr_pshared</a> (pthread_mutexattr_t *arg1, JITNINT arg2)</td></tr>
<tr class="memdesc:ga6f40d295a84a6be7b525ae65ffb42ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set process-shared state attribute of mutex attribute object.  <a href="#ga6f40d295a84a6be7b525ae65ffb42ec2">More...</a><br /></td></tr>
<tr class="separator:ga6f40d295a84a6be7b525ae65ffb42ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a563324d7992df67a41717c023659f8"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga0a563324d7992df67a41717c023659f8">PLATFORM_setMutexAttr_type</a> (pthread_mutexattr_t *arg1, JITNINT arg2)</td></tr>
<tr class="memdesc:ga0a563324d7992df67a41717c023659f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set mutex type attribute of mutex attribute object.  <a href="#ga0a563324d7992df67a41717c023659f8">More...</a><br /></td></tr>
<tr class="separator:ga0a563324d7992df67a41717c023659f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb256d1a986b67c23065da8f64537fe1"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gaeb256d1a986b67c23065da8f64537fe1">PLATFORM_destroyMutexAttr</a> (pthread_mutexattr_t *arg1)</td></tr>
<tr class="memdesc:gaeb256d1a986b67c23065da8f64537fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a previously initialized mutex attribute object.  <a href="#gaeb256d1a986b67c23065da8f64537fe1">More...</a><br /></td></tr>
<tr class="separator:gaeb256d1a986b67c23065da8f64537fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b1ac81e0e0637ad244cd4080988c8b"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gad8b1ac81e0e0637ad244cd4080988c8b">PLATFORM_destroyMutex</a> (pthread_mutex_t *arg1)</td></tr>
<tr class="memdesc:gad8b1ac81e0e0637ad244cd4080988c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a mutex.  <a href="#gad8b1ac81e0e0637ad244cd4080988c8b">More...</a><br /></td></tr>
<tr class="separator:gad8b1ac81e0e0637ad244cd4080988c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6c591891ecdd92161a67b51375f8e9d"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gab6c591891ecdd92161a67b51375f8e9d">PLATFORM_lockMutex</a> (pthread_mutex_t *arg1)</td></tr>
<tr class="memdesc:gab6c591891ecdd92161a67b51375f8e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a mutex.  <a href="#gab6c591891ecdd92161a67b51375f8e9d">More...</a><br /></td></tr>
<tr class="separator:gab6c591891ecdd92161a67b51375f8e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aabae5c6698503c73c816e25b4de85a"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga5aabae5c6698503c73c816e25b4de85a">PLATFORM_trylockMutex</a> (pthread_mutex_t *arg1)</td></tr>
<tr class="memdesc:ga5aabae5c6698503c73c816e25b4de85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a mutex.  <a href="#ga5aabae5c6698503c73c816e25b4de85a">More...</a><br /></td></tr>
<tr class="separator:ga5aabae5c6698503c73c816e25b4de85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949d1a557089ac8532d3b66ca8ec6c0b"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga949d1a557089ac8532d3b66ca8ec6c0b">PLATFORM_unlockMutex</a> (pthread_mutex_t *arg1)</td></tr>
<tr class="memdesc:ga949d1a557089ac8532d3b66ca8ec6c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a mutex.  <a href="#ga949d1a557089ac8532d3b66ca8ec6c0b">More...</a><br /></td></tr>
<tr class="separator:ga949d1a557089ac8532d3b66ca8ec6c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a4ebd3e4bbcfa3393d734cd3630aded"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga6a4ebd3e4bbcfa3393d734cd3630aded">PLATFORM_initCondVar</a> (pthread_cond_t *arg1, const pthread_condattr_t *arg2)</td></tr>
<tr class="memdesc:ga6a4ebd3e4bbcfa3393d734cd3630aded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize condition variable.  <a href="#ga6a4ebd3e4bbcfa3393d734cd3630aded">More...</a><br /></td></tr>
<tr class="separator:ga6a4ebd3e4bbcfa3393d734cd3630aded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a1842a6363355ea8965f90c9a91df2"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gaf0a1842a6363355ea8965f90c9a91df2">PLATFORM_initCondVarAttr</a> (pthread_condattr_t *arg1)</td></tr>
<tr class="memdesc:gaf0a1842a6363355ea8965f90c9a91df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize condition variable attributes.  <a href="#gaf0a1842a6363355ea8965f90c9a91df2">More...</a><br /></td></tr>
<tr class="separator:gaf0a1842a6363355ea8965f90c9a91df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e092dcfd27529ae5945f18adb84289"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga53e092dcfd27529ae5945f18adb84289">PLATFORM_setCondVarAttr_pshared</a> (pthread_condattr_t *arg1, JITNINT arg2)</td></tr>
<tr class="memdesc:ga53e092dcfd27529ae5945f18adb84289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the process-shared condition variable attributes.  <a href="#ga53e092dcfd27529ae5945f18adb84289">More...</a><br /></td></tr>
<tr class="separator:ga53e092dcfd27529ae5945f18adb84289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd84e22b3115423283c5026545fbd652"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gacd84e22b3115423283c5026545fbd652">PLATFORM_waitCondVar</a> (pthread_cond_t *arg1, pthread_mutex_t *arg2)</td></tr>
<tr class="memdesc:gacd84e22b3115423283c5026545fbd652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a condition.  <a href="#gacd84e22b3115423283c5026545fbd652">More...</a><br /></td></tr>
<tr class="separator:gacd84e22b3115423283c5026545fbd652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c90df8c01d1a05826f689050131f3fa"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga2c90df8c01d1a05826f689050131f3fa">PLATFORM_signalCondVar</a> (pthread_cond_t *arg1)</td></tr>
<tr class="memdesc:ga2c90df8c01d1a05826f689050131f3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a condition.  <a href="#ga2c90df8c01d1a05826f689050131f3fa">More...</a><br /></td></tr>
<tr class="separator:ga2c90df8c01d1a05826f689050131f3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16172171c929567a9871244c9c1e20a4"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga16172171c929567a9871244c9c1e20a4">PLATFORM_broadcastCondVar</a> (pthread_cond_t *arg1)</td></tr>
<tr class="memdesc:ga16172171c929567a9871244c9c1e20a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a condition.  <a href="#ga16172171c929567a9871244c9c1e20a4">More...</a><br /></td></tr>
<tr class="separator:ga16172171c929567a9871244c9c1e20a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f2141bec4405f00ba480597b196e65b"><td class="memItemLeft" align="right" valign="top">JITNINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga6f2141bec4405f00ba480597b196e65b">PLATFORM_destroyCondVar</a> (pthread_cond_t *arg1)</td></tr>
<tr class="memdesc:ga6f2141bec4405f00ba480597b196e65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy condition variable.  <a href="#ga6f2141bec4405f00ba480597b196e65b">More...</a><br /></td></tr>
<tr class="separator:ga6f2141bec4405f00ba480597b196e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga16172171c929567a9871244c9c1e20a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_broadcastCondVar </td>
          <td>(</td>
          <td class="paramtype">pthread_cond_t *&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcast a condition. </p>
<p><br />
 This function unblocks all threads blocked on the specified condition variable. <br />
 The function has no effect if no threads are blocked on the condition variable. <a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga16172171c929567a9871244c9c1e20a4" title="Broadcast a condition. ">PLATFORM_broadcastCondVar()</a> may be called by a thread whether or not it owns the mutex which threads calling <a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gacd84e22b3115423283c5026545fbd652" title="Wait on a condition. ">PLATFORM_waitCondVar()</a> have associated with the condition variable during their waits. <br />
 However, if predictable scheduling behavior is required, then that mutex should be locked by the thread calling <a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga16172171c929567a9871244c9c1e20a4" title="Broadcast a condition. ">PLATFORM_broadcastCondVar()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condVar</td><td>Is the condition variable to broadcast.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2fa4004ae226cf350447a6c3b4b9e63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_createThread </td>
          <td>(</td>
          <td class="paramtype">pthread_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pthread_attr_t *&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>thread_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new thread. </p>
<p>function is used to create a new thread, with attributes specified by 'attr', within a process. (see PLATFORM_initThreadAttr) At creation, the thread executes 'thread_function', with arg as its sole argument. The calling function must ensure that arg remains valid for the new thread throughout its lifetime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Is the location where the ID of the newly created thread should be stored, or NULL if the thread ID is not required. </td></tr>
    <tr><td class="paramname">attr</td><td>Is the thread attribute object specifying the attributes for the thread that is being created. If attr is NULL, the thread is created with default attributes. </td></tr>
    <tr><td class="paramname">thread_function</td><td>Is the main function for the thread; the thread begins executing user code at this address. </td></tr>
    <tr><td class="paramname">arg</td><td>Is the argument passed to start.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f2141bec4405f00ba480597b196e65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_destroyCondVar </td>
          <td>(</td>
          <td class="paramtype">pthread_cond_t *&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy condition variable. </p>
<p>The condition variable must not be used after it has been destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condVar</td><td>Is the condition variable to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gad8b1ac81e0e0637ad244cd4080988c8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_destroyMutex </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a mutex. </p>
<p>The mutex must not be used after it has been destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Is the mutex to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb256d1a986b67c23065da8f64537fe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_destroyMutexAttr </td>
          <td>(</td>
          <td class="paramtype">pthread_mutexattr_t *&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a previously initialized mutex attribute object. </p>
<p>The attribute object may not be reused until it is reinitialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutexAttr</td><td>Is the mutex attribute object to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb5e87e2a6306bc37bd88781ba3e2d73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_equalThread </td>
          <td>(</td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare thread IDs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread1</td><td>First thread handler </td></tr>
    <tr><td class="paramname">thread2</td><td>Second thread handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the the handlers refers to the same thread, function returns non-zero value (True). Otherwise, 0 (False) is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a2ba08031740378a202fbeeea4ee378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t PLATFORM_getSelfThreadID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ID of the calling thread. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the ID of the calling thread. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a4ebd3e4bbcfa3393d734cd3630aded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_initCondVar </td>
          <td>(</td>
          <td class="paramtype">pthread_cond_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pthread_condattr_t *&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize condition variable. </p>
<p>If attr is NULL, the condition variable is initialized with default attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condVar</td><td>Is the condition variable to initialize. </td></tr>
    <tr><td class="paramname">attr</td><td>Specifies the attributes used for initializing the condition variable, or NULL if default attributes should be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0a1842a6363355ea8965f90c9a91df2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_initCondVarAttr </td>
          <td>(</td>
          <td class="paramtype">pthread_condattr_t *&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize condition variable attributes. </p>
<p>Initialize condition variable attributes object with the default settings for each attribute.<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condVar</td><td>Is the condition variable attribute object to be initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gae8c0a9cfc35da8135d3447d739f385bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_initMutex </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pthread_mutexattr_t *&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Is the mutex to initialize. </td></tr>
    <tr><td class="paramname">attr</td><td>Specifies the attributes to use to initialize the mutex, or NULL if default attributes should be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ee60da7a9b3b96ac9927ce51c36b568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_initMutexAttr </td>
          <td>(</td>
          <td class="paramtype">pthread_mutexattr_t *&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize mutex attribute object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>Is the mutex attribute object to be initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c57e7902a9fa1ece3b51cba72aeb6b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_initThreadAttr </td>
          <td>(</td>
          <td class="paramtype">pthread_attr_t *&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialize thread attribute object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>Is the thread attribute object to be initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09e5bf1362c602d7d43ca8467e92db76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_joinThread </td>
          <td>(</td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for thread termination. </p>
<p>This function suspends execution of the calling thread until the target thread terminates, unless the target thread has already terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Is the thread to wait for. </td></tr>
    <tr><td class="paramname">status</td><td>Is the location where the exit status of the joined thread is stored. This can be set to NULL if the exit status is not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gab6c591891ecdd92161a67b51375f8e9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_lockMutex </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a mutex. </p>
<p>If the mutex is already locked, the calling thread blocks until the mutex becomes available.<br />
This operation returns with the mutex in the locked state with the calling thread as its owner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Is the mutex to lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga39518c80bcbdd62282767649e35a2ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_pthread_once </td>
          <td>(</td>
          <td class="paramtype">pthread_once_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>thread_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic package initialization. </p>
<p>The first call to this function by any thread in a process, with a given 'once_control', calls the 'thread_function' with no arguments. <br />
Subsequent calls with the same 'once_control' do not call the thread_function.<br />
Default once_control is PTHREAD_ONCE_INIT constant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">once_control</td><td>Determines whether the associated initialization routine has been called. </td></tr>
    <tr><td class="paramname">thread_function</td><td>Specifies an initialize routine to be run.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3b73a33ac6cff82cb84a09d627e854e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_sched_get_priority_max </td>
          <td>(</td>
          <td class="paramtype">JITNINT&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get priority max limit. </p>
<p>The functions returns the appropriate maximum value, for the scheduling policy specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>one of the scheduling policy values defined in &lt;sched.h&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, returns the appropriate maximum value. Otherwise, returns -1. </dd></dl>

</div>
</div>
<a class="anchor" id="gadaa074d9567d04d79ca14838b22234ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_sched_get_priority_min </td>
          <td>(</td>
          <td class="paramtype">JITNINT&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get priority min limit. </p>
<p>The functions returns the appropriate minimum value, for the scheduling policy specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>one of the scheduling policy values defined in &lt;sched.h&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, returns the appropriate minimum value. Otherwise, returns -1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga99633fd674713b69a6926be43706979b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_sched_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yeld schedule. </p>
<p>The function forces the running thread to relinquish the processor to allow another thread to run.</p>
<dl class="section return"><dt>Returns</dt><dd>always returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga53e092dcfd27529ae5945f18adb84289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_setCondVarAttr_pshared </td>
          <td>(</td>
          <td class="paramtype">pthread_condattr_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JITNINT&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the process-shared condition variable attributes. </p>
<p>The condition variable's process-shared state determines whether the condition variable can be used to synchronize threads within the current process or threads within all processes on the system.<br />
Valid settings for pshared include:</p><ul>
<li>PTHREAD_PROCESS_PRIVATE: Creates a condition variable that can only be used to synchronize threads within the current process.</li>
<li>PTHREAD_PROCESS_SHARED: Creates a condition variable that can be used to synchronize threads within all processes on the system</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>Is the condition variable attribute object to be initialized. </td></tr>
    <tr><td class="paramname">pshared</td><td>Is the condition variable process-shared state attribute value; one of the values specified before.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f40d295a84a6be7b525ae65ffb42ec2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_setMutexAttr_pshared </td>
          <td>(</td>
          <td class="paramtype">pthread_mutexattr_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JITNINT&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set process-shared state attribute of mutex attribute object. </p>
<p>Sets the process-shared state attribute in the specified mutex attribute object.<br />
 The mutex's process-shared state determines whether the mutex can be used to synchronize threads within the current process or threads within all processes on the system.<br />
 Valid settings for pshared include:</p><ul>
<li>PTHREAD_PROCESS_PRIVATE: Creates a mutex that can only be used to synchronize threads within the current process.</li>
<li>PTHREAD_PROCESS_SHARED: Creates a mutex that can be used to synchronize threads within all processes on the system.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>Is the mutex attribute object. </td></tr>
    <tr><td class="paramname">pshared</td><td>Is the mutex process-shared state attribute value, one of the values specified before.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a563324d7992df67a41717c023659f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_setMutexAttr_type </td>
          <td>(</td>
          <td class="paramtype">pthread_mutexattr_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JITNINT&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set mutex type attribute of mutex attribute object. </p>
<p>Valid settings for type include:<br />
</p><ul>
<li>PTHREAD_MUTEX_NORMAL This type of mutex does not detect deadlock. An attempt to relock this mutex without first unlocking it deadlocks. Attempting to unlock a mutex locked by a different thread results in undefined behavior. Attempting to unlock an unlocked mutex results in undefined behavior.</li>
<li>PTHREAD_MUTEX_ERRORCHECK This type of mutex provides error checking. An attempt to relock this mutex without first unlocking it returns with an error. An attempt to unlock a mutex that another thread has locked returns with an error. An attempt to unlock an unlocked mutex returns with an error.</li>
<li>PTHREAD_MUTEX_RECURSIVE A thread attempting to relock this mutex without first unlocking it succeeds in locking the mutex. The relocking deadlock that can occur with mutexes of type PTHREAD_MUTEX_NORMAL cannot occur with this type of mutex. Multiple locks of this mutex require the same number of unlocks to release the mutex before another thread can acquire the mutex. An attempt to unlock a mutex that another thread has locked returns with an error. An attempt to unlock an unlocked mutex returns with an error.</li>
<li>PTHREAD_MUTEX_DEFAULT Attempting to recursively lock a mutex of this type results in undefined behavior. Attempting to unlock a mutex of this type that was not locked by the calling thread results in undefined behavior. Attempting to unlock a mutex of this type that is not locked results in undefined behavior.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>Is the mutex attribute object. </td></tr>
    <tr><td class="paramname">type</td><td>The mutex type attribute value; one of the values specified above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga150cc3d61124fc0a8b40cf724d01282e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_setThreadAttr_inheritsched </td>
          <td>(</td>
          <td class="paramtype">pthread_attr_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JITNINT&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set scheduling parameter inheritance state attribute. </p>
<p><br />
 NOTE: this function takes effect only under Linux, by the differences of other platforms thread implementation.<br />
 The thread's scheduling parameter inheritance state determines whether scheduling parameters are explicitly specified in this attribute object, or if scheduling attributes should be inherited from the creating thread. <br />
 Valid settings for 'inheritsched' include:</p><ul>
<li>PTHREAD_EXPLICIT_SCHED: Scheduling parameters for the newly created thread are specified in the thread attribute object.</li>
<li>PTHREAD_INHERIT_SCHED: Scheduling parameters for the newly created thread are the same as those of the creating thread.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>Is the thread attribute object to be set. </td></tr>
    <tr><td class="paramname">inheritsched</td><td>Is the thread scheduling parameter inheritance state attribute value, one of the values specified before.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga65143bde61a965df3461b3147efbe580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_setThreadAttr_schedparam </td>
          <td>(</td>
          <td class="paramtype">pthread_attr_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sched_param *&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set scheduling parameter attribute. </p>
<p><br />
 NOTE: this function takes effect only under Linux, by the differences of other platforms thread implementation.<br />
 Sets the scheduling parameter attribute in the specified attribute object, determined by the scheduling policy specified in the attribute object.<br />
 The only required member of the param structure for the SCHED_FIFO, SCHED_OTHER, or SCHED_RR policies is sched_priority.<br />
 This function can be used to specify the starting priority of a newly created thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>Is the thread attribute object to be set. </td></tr>
    <tr><td class="paramname">param</td><td>Is the thread scheduling parameter attribute value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gae94c0df82573340fc03e3329505ff222"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_setThreadAttr_schedpolicy </td>
          <td>(</td>
          <td class="paramtype">pthread_attr_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JITNINT&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set scheduling policy attribute. </p>
<p><br />
 NOTE: this function takes effect only under Linux, by the differences of other platforms thread implementation.<br />
 The thread's scheduling policy attribute determines how time slices are scheduled for the thread.<br />
 Valid settings for policy include:</p><ul>
<li>SCHED_FIFO: Threads are scheduled in a first-in-first-out order within each priority.</li>
<li>SCHED_OTHER: Scheduling behavior is determined by the operating system.</li>
<li>SCHED_RR: Threads are scheduled in a round-robin fashion within each priority. The specified scheduling policy will only be used if the scheduling parameter inheritance attribute is PTHREAD_EXPLICIT_SCHED.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>Is the thread attribute object to be set. </td></tr>
    <tr><td class="paramname">policy</td><td>Is the thread scheduling policy attribute value, one of the values specified before.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga10dac894350cd3531c5ec74cc4614066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_setThreadAttr_scope </td>
          <td>(</td>
          <td class="paramtype">pthread_attr_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JITNINT&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set scheduling scope attribute. </p>
<p><br />
 NOTE: this function takes effect only under Linux, by the differences of other platforms thread implementation. <br />
 Sets the scheduling scope attribute in the specified attribute object.The thread's scheduling scope attribute determines whether thread-scheduling decisions apply to threads in a given process, or system-wide to all threads. <br />
 valid settings for scope include:</p><ul>
<li>PTHREAD_SCOPE_PROCESS: Threads are scheduled with respect to other threads in the current process.</li>
<li>PTHREAD_SCOPE_SYSTEM : Threads are scheduled with respect to all threads in the system. <br />
 The specified scheduling scope is only used if the scheduling parameter inheritance attribute is PTHREAD_EXPLICIT_SCHED.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>Is the thread attribute object to be set. </td></tr>
    <tr><td class="paramname">scope</td><td>Is the thread scheduling scope attribute value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gadef31dcc2d43c0ebe50b31648ef40a0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_setThreadAttr_stackSize </td>
          <td>(</td>
          <td class="paramtype">pthread_attr_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set thread stack size attribute. </p>
<p><br />
 NOTE: this function takes effect only under Linux, by the differences of other platforms thread implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>Is the thread attribute object to be set . </td></tr>
    <tr><td class="paramname">stacksize</td><td>Is the address of location used to store the current stack size attribute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c90df8c01d1a05826f689050131f3fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_signalCondVar </td>
          <td>(</td>
          <td class="paramtype">pthread_cond_t *&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal a condition. </p>
<p><br />
 This function unblocks a single thread blocked on the specified condition variable. <br />
 The function has no effect if no threads are blocked on the condition variable. <br />
 This function may be called by a thread whether or not it owns the mutex which threads calling <a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gacd84e22b3115423283c5026545fbd652" title="Wait on a condition. ">PLATFORM_waitCondVar()</a> have associated with the condition variable during their waits. However, if predictable scheduling behavior is required, then that mutex should be locked by the thread calling <a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga2c90df8c01d1a05826f689050131f3fa" title="Signal a condition. ">PLATFORM_signalCondVar()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condVar</td><td>Is the condition variable to signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60728cd6aaa9da6816d85bf2fc55cf4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int PLATFORM_threadHashFunc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute hash function from thread handler. </p>
<p>Needed for hash tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the unsigned int referred to the element. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5aabae5c6698503c73c816e25b4de85a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_trylockMutex </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock a mutex. </p>
<p>If the mutex is already locked, an error is returned. Otherwise, this operation returns with the mutex in the locked state with the calling thread as its owner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Is the mutex to try to lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga949d1a557089ac8532d3b66ca8ec6c0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_unlockMutex </td>
          <td>(</td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a mutex. </p>
<p>If there are threads blocked on the mutex object when <a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga949d1a557089ac8532d3b66ca8ec6c0b" title="Unlock a mutex. ">PLATFORM_unlockMutex()</a> is called, resulting in the mutex becoming available, the scheduling policy is used to determine which thread acquires the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Is the mutex to unlock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gacd84e22b3115423283c5026545fbd652"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JITNINT PLATFORM_waitCondVar </td>
          <td>(</td>
          <td class="paramtype">pthread_cond_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_mutex_t *&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a condition. </p>
<p>The function blocks on the specified condition variable, which atomically releases the specified mutex and causes the calling thread to block on the condition variable The blocked thread may be awakened by a call to <a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga2c90df8c01d1a05826f689050131f3fa" title="Signal a condition. ">PLATFORM_signalCondVar()</a> or <a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#ga16172171c929567a9871244c9c1e20a4" title="Broadcast a condition. ">PLATFORM_broadcastCondVar()</a>. <br />
 This function atomically releases the mutex, causing the calling thread to block on the condition variable Upon successful completion, the mutex is locked and owned by the calling thread. <br />
 When using condition variables, there should always be a boolean predicate involving shared variables related to each condition wait. This predicate should become true only when the thread should proceed. Because the return from <a class="el" href="group___t_h_r_e_a_d_s___b_a_s_e.html#gacd84e22b3115423283c5026545fbd652" title="Wait on a condition. ">PLATFORM_waitCondVar()</a> does not indicate anything about the value of this predicate, the predicate should be reevaluated on return. Unwanted wakeups from pthread_cond_wait() may occur (since another thread could have obtained the mutex, changed the state and released the mutex, prior to this thread obtaining the mutex); the reevaluation of the predicate ensures consistency. <br />
 The function is a cancellation point. If a cancellation request is acted on while in a condition wait when the cancellation type of a thread is set to deferred, the mutex is reacquired before calling the first cancellation cleanup handler. In other words, the thread is unblocked, allowed to execute up to the point of returning from the call pthread_cond_wait(), but instead of returning to the caller, it performs the thread cancellation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condVar</td><td>Is the condition variable to wait on. </td></tr>
    <tr><td class="paramname">mutex</td><td>Is the mutex associated with the condition variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, non-zero value is returned. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 30 2014 10:00:57 for ILDJIT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
