<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>ILDJIT: Internal Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ildjit_logo_small.jpeg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">ILDJIT
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Internal Methods</div>  </div>
</div><!--header-->
<div class="contents">
<p>Here we provide a Howto for the implementation of the internal methods inside the ILDJIT project.</p>
<p><br />
 <br />
 <br />
 <br />
 <b>POINT 1 - WHAT ARE INTERNAL CALLS</b> <br />
 <br />
 For performance reasons C# standard states that some functionalities have to be implemented at a native level, which is in C code inside the compiler. Internal calls are functions inside the CIL compiler implementing CIL class methods that are marked with the <code>[MethodImpl(MethodImplOptions.InternalCall)]</code> metadata tag. <br />
 <br />
 <br />
 <br />
 <b>POINT 2 - IMPLEMENTATION OF AN INTERNAL CALL</b> <br />
 <br />
 <b>Where insert your internal call</b> <br />
 You can find the files where internal calls are implemented in the iljit module. Here, there are many files <code>called internal_calls_X.c</code> and <code>internal_calls_X.h</code> where X is the name of class that you want to implement. Here you have to insert your code of internal call (e.g. If you are implementing an internal call about <code>String</code> class, you insert the function in <code>internal_calls_string.c</code> file). There isnâ€™t a straight correspondence between .cs files (one for each C# class) and internal_calls files in iljit, in which functions are grouped by semantic. So, for instance, in <code>internal_calls_string.c</code> you also find other functions about string, like the implementation of the internal methods of <code>StringBuilder</code> and <code>DefaultEncoding</code> classes. <br />
 <br />
 <b>The signature of an internal call</b> <br />
 The signature of a function that implements an internal call is composed by a return type, the name of the function and a list of formal parameters, the same that you find in the signature of the C# method in the pnetlib .cs file. (eg. <code>String.cs</code>). </p><ul>
<li>
Return type: it is the return type of the method of the class C# translated in ILDJIT type (see table below). </li>
<li>
Name of function: it is composed by the package that contains the class and the name of the class: for example, for the method <code>InternalOrdinal</code> contained in <code>String</code> class in <code>System</code> package the name of the function will be <code>System_String_InternalOrdinal</code>. </li>
<li>
Formal parameters: they are the same parameters that you find in C# method signature, written as return type (translate in ILDJIT type) and name of parameter. </li>
</ul>
<p>There is a difference between the implementation of an internal call about a method that belong to a class and a method that belong to a structure in the return type and in the formal parameters. To see this difference, look at the point 5. <br />
 <br />
 <b>Implementation</b> <br />
 After you have declared your signature in the appropriate <code>internal_calls_X</code> files you can proceed to implement your internal call. You must use C code to write the internal call. Also ILDJIT uses support libraries that can help you to write internal calls. You can use a <a class="el" href="structt__system.html" title="System struct. ">t_system</a> structure to call other function and let your code be more efficient and readable. To see how to use <a class="el" href="structt__system.html" title="System struct. ">t_system</a> structure read the point 3. The correspondence between ILJIT and C# types is summarized in the table at the end of this document. <br />
 <br />
 <br />
 <br />
 <b>POINT 3 - USE THE SUPPORT LIBRARIES TO IMPLEMENT INTERNAL CALLS.</b> <br />
 <br />
 <b>The support libraries</b> <br />
 Internal calls are written in C code. ILDJIT helps you with others functions that you can find in iljit module. Each file <code>internal_call_X</code> is linked to another file called <code>lib_X.c</code> where there are implemented these support function. (e.g <code>internal_calls_string.c</code> is linked to <code>lib_string.c</code>).To use these functionalities you have to declare a <code><a class="el" href="structt__system.html" title="System struct. ">t_system</a></code> variable. <br />
 Lib files contains general purpose function for accessing object fields through fields offsets (eg. field length of a string) and utility functions (like <code>compareStrings</code> or <code>getUTF8copy</code>) that facilitates operations on the objects. Internal_calls files, instead, contains only the functions that implements the internal calls. In these implementation functions you can access a <code>lib_X</code> function through a <code><a class="el" href="structt__system.html" title="System struct. ">t_system</a></code> structure. <br />
 <br />
 <b>What is <code><a class="el" href="structt__system.html" title="System struct. ">t_system</a></code> structure</b> <br />
 <code><a class="el" href="structt__system.html" title="System struct. ">t_system</a></code> is a structure that is defined in system.h file that you can find in iljit module. <code><a class="el" href="structt__system.html" title="System struct. ">t_system</a></code> holds pointers to others structures to manage the libraries function. Each field of <a class="el" href="structt__system.html" title="System struct. ">t_system</a> is a pointer to a class manager structure (<code>stringManager</code>, <code>arrayManager</code>, and so on), which contains function pointers to lib functions defined in lib files. To use this functionality in your internal call, you have to declare a pointer to <a class="el" href="structt__system.html" title="System struct. ">t_system</a>, initialize it with the instruction <code>getSystem(NULL)</code>. </p><div class="fragment"><div class="line"><a class="code" href="structt__system.html">t_system</a> *system;</div>
<div class="line">system=getSystem(NULL);</div>
</div><!-- fragment --><p> Now to call a function defined in <code>lib_file</code> you call <code>(system-&gt;classManager).functionName</code>, where <code>classManager</code> is the name of the class you are implementing (or better the name of the semantic group of function to which your class belongs). </p><div class="fragment"><div class="line">(system-&gt;stringManager).getLength(str);</div>
<div class="line">where str is a <span class="keywordtype">void</span>* that points to C# <span class="keywordtype">string</span> <span class="keywordtype">object</span>.</div>
</div><!-- fragment --><p> You can also implement a library function ad hoc for your purpose, modifying <code>lib_file</code> that already exists. <br />
 <br />
 <b>How to add a new library function in <code>lib_X</code></b> <br />
 If you think a function is useful or necessary to manipulate the objects of the class you are implementing also outside the <code>internal_calls_X</code> file or if you believe this functionality can make your code more readable because it can hide usefulness implementation details, you should move the implementation code in the <code>lib_X</code> file. To do so you have to: </p><ul>
<li>
declare the signature of the new function in the <code>lib_X.h</code> file </li>
<li>
add the implementation code of the new function in the <code>lib_X.c</code> file </li>
<li>
add a new pointer to the function in the Xmanager structure in <code>lib_X.h</code> file </li>
<li>
add the function pointer assignment in the initialization function inside <code>lib_X.h</code>. If you don't remember to do this assignment the pointer to the function points to <code>NULL</code> and a call <code>(system-&gt;XManager).yourFunctionPointer</code> will produce a <code>Segmentation Fault</code> error during execution) </li>
</ul>
<p><br />
 <br />
 <br />
 <b>POINT 4 - ADD YOUR INTERNAL CALL AT THE TREE OF THE INTERNAL CALLS</b> <br />
 <br />
 <b>The file <code>lib_internalCall.gperf</code></b> <br />
 When you have finished to implement your internal call in files (<code>internal_calls_file</code> and <code>lib_files</code>) you have to add your internal call at the table of internal calls. In iljit module you can find a file that manage this table. This is called <code>lib_internalCall.gperf/code&gt; and it allows you to associate the call of a C# method with the correspondent internal calls written in C. <br />
 To allow this association, methods are organized as a table structure <br />
 <br />
<b>Add your internal call</b> <br />
 When you add your internal call you have to provide a new entry. An Entry is composed by two things the identifier and the reference of function to call </p><ul>
<li>
The identifier is composed by full qualified name of method (Namespace.TypeName.MethodName) followed by TypeName (e.g. for System.String[] use only String[]) of all in parameters separated by special character '_'. </li>
<li>
The reference is a simple pointer to function associated to internal call. See the next point for further details about implementation of method. </li>
</ul>
<p><br />
 <br />
 Example: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keyword">public</span> String Replace(<span class="keywordtype">char</span> oldChar, <span class="keywordtype">char</span> newChar);                               <span class="comment">//C# method signature</span></div>
<div class="line">        System.String.Replace_char_char, function_implementing_method                                 <span class="comment">//internal call entry</span></div>
</div><!-- fragment --><p> <br />
 <br />
 <br />
 <b>POINT 5 - IMPLEMENTATION OF A METHOD THAT HAVE A STRUCTURE AS INPUT PARAMETER (OR RETURN TYPE)</b> <br />
 <br />
 When you implement an internal call you can find two cases: static methods and virtual methods. <br />
 If you are implementing a static method the list of parameters is the same of the C# signature of the method. Instead, for virtual methods, you have to add an additional parameter at the beginning of the list, which is the object that calls the method. This parameter is usually called <code>void *_this</code> and is a pointer to the calling object. <br />
 Indifferently by the method is static or virtual, you can find or not a structure among its input parameters and it can return or not a structure as output parameter. So you have 3 different cases. </p><ol>
<li>
<p class="startli">If the method has no input nor output structure parameters, the implementation is normally done with the list of the C# signature parameters.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If the method has input structure parameters, the structure is passed to the implementation function by reference through a void pointer <code>(void*)</code> . The implementation function must not modify the structure, because the structure is considered a read-only parameter. <br />
 <br />
 Example: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keyword">public</span> String Replace(<span class="keywordtype">char</span> oldChar, <span class="keywordtype">char</span> newChar);                               <span class="comment">//C# method signature</span></div>
<div class="line"><span class="keywordtype">void</span> * System_String_Replace(<span class="keywordtype">void</span> *_this, JITINT16 oldChar, JITINT16 newChar);          <span class="comment">//internal call</span></div>
</div><!-- fragment --><p> <br />
 In C# String is represented by a class. There is a return type <code>String</code> in the method signature that corresponded to a return type <code>void*</code> in the internal call. In the formal parameters of internal call there is a <code>void*_this</code> that is a pointer to the object <code>String</code> which calls this method.</p>
<p class="endli"></p>
</li>
<li>
If the method has output structure parameter, put an extra void pointer at the end of the input parameter list. You can name it <code>void*_ret</code> or <code>void* _result</code> and it is a pointer to the output structure that is allocated on the stack of the caller method. <br />
 <br />
 Example: <div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keyword">public</span> ValueType GetNextArg(RuntimeTypeHandle type);        <span class="comment">//C# method signature</span></div>
<div class="line"><span class="keywordtype">void</span> System_ArgIterator_GetNextArg(<span class="keywordtype">void</span> *_this,<span class="keywordtype">void</span> *_result);             <span class="comment">//internal call</span></div>
</div><!-- fragment --> <br />
 In C# <code>ValueType</code> is represented by a structure and in this case is the return type of method <code>GetNextArg</code> of <code>ArgIterator</code> structure. So in the internal call the return type is not a type that represent a <code>ValueType</code> but it is void. You have to add an additional parameter. In fact the internal call has two formal parameters: the first <code>(void* _this)</code> that refers to a <code>RuntimeTypeHandle</code> object and the second (<code>void* _result</code>) that is the return type <code>ValueType</code> . Than the <code>void* _result</code> will be used as a return value. </li>
</ol>
<p><br />
 <br />
 <br />
 <b>POINT 6 - A COMPLETE EXAMPLE: <code>System.String.Trim()</code> </b> </p><ol>
<li>
<p class="startli">Compose the signature of the function <code>System.String.Trim</code> from the definition of the method <code>Trim</code> in <code>pnetlib-0.8.0/runtime/System/String.cs</code>: </p><div class="fragment"><div class="line">[MethodImpl(MethodImplOptions.InternalCall)]</div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">private</span> String Trim(<span class="keywordtype">char</span>[] trimChars, <span class="keywordtype">int</span> trimFlags);                             <span class="comment">//C# method signature</span></div>
<div class="line"><span class="keywordtype">void</span> System_String_Trim(<span class="keywordtype">void</span> *_this, <span class="keywordtype">void</span> *trimCharsArray, JITINT32 trimFlags);          <span class="comment">//internal call</span></div>
</div><!-- fragment --><p> and insert it in <code>internal_calls_string.h</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Insert in internal_calls_string.c the implementation of the function System.String.Trim, where you can use library functions defined in lib_string.h: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> * System_String_Trim(<span class="keywordtype">void</span> *_this, <span class="keywordtype">void</span> *trimCharsArray, JITINT32 trimFlags)</div>
<div class="line">{</div>
<div class="line">     <a class="code" href="structt__system.html">t_system</a> *system;</div>
<div class="line">     <span class="keywordtype">void</span> *obj;</div>
<div class="line">     JITINT32 len;</div>
<div class="line"></div>
<div class="line">     system=getSystem(NULL);</div>
<div class="line">     obj = (system-&gt;stringManager).trim(_this,trimCharsArray,trimFlags);</div>
<div class="line">     len = (system-&gt;stringManager).getLength(_this);</div>
<div class="line"></div>
<div class="line">     <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
Insert in lib_internalCall.gperf the line corrisponding to the internal call: <div class="fragment"><div class="line"><span class="comment">// System.String.Trim</span></div>
<div class="line">System.String.Trim_Char[]_Int32, System_String_Trim</div>
</div><!-- fragment --> </li>
</ol>
<p></code></p>
<p><code> <br />
 <br />
 The correspondence between C, C#, ILDJIT and IR types is summarized in the table below. <br />
 <br />
 </p><table  width="60%" bordercolor="#000000" cellpadding="4" cellspacing="0">
</table>
<p></code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code><b>C# types</b></code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><b>CLI types</b></code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><b>C types</b></code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><b>JIT types [1]</b></code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><b>IR types [2]</b></code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><b>IR types code</b></code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>bool</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.Boolean</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>unsigned char</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITBOOLEAN</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRINT8</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>5</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>char</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.Char</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>unsigned short int</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITUINT16 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRUINT16</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>10</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>sbyte</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.SByte</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>signed char</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITINT8 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRINT8</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>4</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>short</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.Int16</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>short int</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITINT16 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRINT16</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>5</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>int</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.Int32</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>int</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITINT32 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRINT32</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>6</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>long</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.Int64</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>long long int</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITINT64 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRINT64</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>7</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>byte</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.Byte</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>unsigned char</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITUINT8 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRUINT8</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>9</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>ushort</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.UInt16</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>unsigned short int</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITUINT16 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRUINT16</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>10</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>uint</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.UInt32</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>unsigned int</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITUINT32 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRUINT32</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>11</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>ulong</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.UInt64</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>unsigned long long int</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITUINT64 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRUINT64</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>12</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>float</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.Single</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>float</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITFLOAT32</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRFLOAT32</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>14</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>double</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.Double</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>double</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITFLOAT64</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRFLOAT64</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>15</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>IntPtr</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.IntPtr</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>int</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITNINT </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRNUINT</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>13</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>IntPtr</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.IntPtr</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>unsigned int</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITNINT </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRNINT</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>8</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>float</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.Single</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>float</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> JITNFLOAT</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRNFLOAT</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>16</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>decimal</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.Decimal</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>void*</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>void*</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRVALUETYPE</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>24</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>string</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.String</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>void*</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>void*</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IROBJECT</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>23</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>object</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>System.object</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>void*</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>void*</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IROBJECT</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>23</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>struct</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code><br />
 </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>void*</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>void*</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRMPOINTER/IRVALUETYPE</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>20</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code> </code></p>
<p><code>enum</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code> System.Enum </code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>int</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>JITINT32</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>IRINT32</code></p>
<p><code>  </code></p>
<p><code> </code></p>
<p><code>20</code></p>
<p><code>   </code></p>
<p><code> </code></p>
<p><code></code></p>
<p><code> <br />
 Notes: <br />
 [1] JIT types are C types defined in libiljitu/src/jitsystem.h <br />
 [2] IR types are numeric constants defined in <a class="el" href="ir__language_8h.html">libiljitu/src/ir_language.h</a></code></p>
<p><code> Next: <a class="el" href="group___compiler_memory.html">Memory API</a> </code></p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 30 2014 10:00:57 for ILDJIT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
