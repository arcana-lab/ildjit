/*
 * Copyright (C) 2010  Campanoni Simone
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#include <stdio.h>
#include <stdlib.h>
#include <jitsystem.h>
#include <xanlib.h>
#include <ir_language.h>
#include <ir_optimization_interface.h>
#include <ir_method.h>
#include <compiler_memory_manager.h>

// My headers
#include <chiara.h>
#include <chiara_system.h>
#include <chiara_loop_transformations.h>
// End

/**
 * @def LOOP_CATCHER
 * @ingroup Loops
 * @brief Loop generated by a catcher routine.
 **/
#define LOOP_CATCHER            1

/**
 * @def LOOP_DOWHILE
 * @ingroup Loops
 * @brief Regular do-while loop.
 **/
#define LOOP_DOWHILE            2

/**
 * @def LOOP_DOWHILE_JUMPS
 * @ingroup Loops
 * @brief Do-while loop containing one jump.
 **/
#define LOOP_DOWHILE_JUMP       3

/**
 * @def LOOP_JUMPS
 * @ingroup Loops
 * @brief Generic loop containing more than one jumps.
 **/
#define LOOP_JUMPS              4

/**
 * @def LOOP_MALFORMED
 * @ingroup Loops
 * @brief Generic loop whose loop exits or back edges are not branchif(not).
 **/
#define LOOP_MALFORMED          5

/**
 * @def LOOP_NESTED
 * @ingroup Loops
 * @brief Generic nested loop whose parent have the same header.
 **/
#define LOOP_NESTED             6

/**
 * @def LOOP_ODD
 * @ingroup Loops
 * @brief Generic loop containing more than one consecutive back edges and loop exits.
 **/
#define LOOP_ODD                7

/**
 * @def LOOP_ONE_BLOCK
 * @ingroup Loops
 * @brief Generic loop made of only one loop (most likely it is a do-while one).
 **/
#define LOOP_ONE_BLOCK          8

/**
 * @def LOOP_UNKNOWN
 * @ingroup Loops
 * @brief Generic loop.
 **/
#define LOOP_UNKNOWN            9

/**
 * @def LOOP_UNSUPPORTED
 * @ingroup Loops
 * @brief Generic unsupported loop.
 **/
#define LOOP_UNSUPPORTED        10

/**
 * @def LOOP_WRONG
 * @ingroup Loops
 * @brief Generic loop whose identification went wrong somewhere.
 **/
#define LOOP_WRONG              11

/**
 * @def LOOP_WHILE
 * @ingroup Loops
 * @brief Generic while (or for) loop.
 **/
#define LOOP_WHILE              12

/**
 * @brief Stucture t_loop_extended.
 *
 * This structure encloses some info for each loop in the IR method.
 * It extends the structur circuit_t defined by ILDJIT.
 **/
typedef struct {
    JITNUINT loop_type;
    loop_t                  *loop;
    loop_t                  *parent_loop;
    XanList                 *loop_instructions;
    XanList                 *loop_exits;
    XanList                 *loop_back_edges;
    ir_instruction_t        *BB_cond_inst;
    ir_instruction_t        *loop_head;
    ir_instruction_t        *loop_cond;
} t_loop_extended;

static inline JITBOOLEAN internal_whilify (XanHashTable *loops, loop_t *loop);
static inline void internal_checkLoop (ir_method_t * method, t_loop_extended * current_loop);
static inline void internal_findLoopCondition (ir_method_t * method, t_loop_extended * current_loop);
static inline void internal_addInstructions (t_loop_extended * current_loop);
static inline void internal_peelLoopStart(ir_method_t *method, loop_t *loop, JITUINT32 numIter);
static inline XanList * internal_getOrderedLoopInsts(ir_method_t *method, ir_instruction_t *firstLoopInst, XanList *loopInsts);
static inline XanList * internal_getOutLabels(ir_method_t *method, XanList *loopInsts);
static inline XanList * internal_peelOneIteration(ir_method_t *method, XanList *loopInsts);
static inline void fixLabels(ir_method_t *method, XanList *peeledInsts, XanList *outLabels);
static inline void patchLoopPreds(ir_method_t *method, XanList *loopInsts, XanList *peeledInsts);
static inline void addFallThroughInstsToList(ir_method_t *method, XanList *loopInsts, XanList *instList, ir_instruction_t *inst);
static inline void getBranchOutLabels(ir_method_t *method, ir_instruction_t *inst, XanList *loopInsts, XanList *outLabels);
static inline void fixClonedBranch(ir_method_t *method, ir_instruction_t *inst, ir_instruction_t *clone, XanList *loopInsts);
static inline JITUINT32 valuePtrHash(void *element);
static inline JITINT32  valuePtrsMatch(void *key1, void *key2);
static inline JITBOOLEAN inLabelList(XanList *labels, IR_ITEM_VALUE value);
static inline void * createValuePtr(IR_ITEM_VALUE val);
static inline void translateLabel(ir_method_t *method, ir_item_t *label, XanHashTable *labelMap, XanList *ignoreLabels);
static inline ir_instruction_t * internal_LOOPS_addPreHeader (loop_t *loop, XanList *predecessors);

void LOOPS_transformToHeaderBodyLoop (ir_optimizer_t *irOptimizer, loop_t *loop) {

    /* Assertions				*/
    assert(irOptimizer != NULL);
    assert(loop != NULL);

    /* Adjust loop to have one single       *
     * backedge that it is a not conditional*
     * branch				*/
    LOOPS_adjustLoopToHaveOneBackedge(loop);

    //TODO

    /* Return				*/
    return;
}

JITBOOLEAN LOOPS_transformToWhileLoop (ir_optimizer_t *irOptimizer, XanHashTable *loops, loop_t *loop) {
    circuit_t          *newloop;
    XanListItem     *item;
    JITBOOLEAN transformed;

    /* Assertions				*/
    assert(irOptimizer != NULL);
    assert(loops != NULL);
    assert(loop != NULL);

    /* Check if the loop is already a while	*
     * loop					*/
    if (LOOPS_isAWhileLoop(irOptimizer, loop)) {
        return JITTRUE;
    }

    /* Transform the loop			*/
    transformed = internal_whilify(loops, loop);

    /* Check if the loop was transformed	*/
    if (!transformed) {
        return JITTRUE;
    }

    /* Optimize the method			*/
    IROPTIMIZER_optimizeMethodAtLevel(irOptimizer, loop->method, 2);

    /* Check if the loop still exist	*/
    if (!IRMETHOD_doesInstructionBelongToMethod(loop->method, loop->header)) {
        return JITFALSE;
    }

    /* Recompute the loops information of   *
     * the IR method			*/
    IROPTIMIZER_callMethodOptimization(irOptimizer, loop->method, LOOP_IDENTIFICATION);

    /* Fetch the new header of the loop	*/
    newloop = IRMETHOD_getTheMoreNestedCircuitOfInstruction(loop->method, loop->header);
    assert(newloop != NULL);
    loop->header = IRMETHOD_getInstructionAtPosition(loop->method, newloop->header_id);
    assert(loop->header != NULL);

    /* Fetch the set of instructions of the	*
     * loop					*/
    xanList_destroyList(loop->instructions);
    xanList_emptyOutList(loop->exits);
    loop->instructions = IRMETHOD_getInstructionsWithinAnyCircuitsOfSameHeader(loop->method, loop->header);
    assert(loop->instructions != NULL);

    /* Set the list of exit points of the	*
     * loop					*/
    item = xanList_first(loop->instructions);
    while (item != NULL) {
        ir_instruction_t        *inst;

        /* Fetch the instruction		*/
        inst = (ir_instruction_t *) item->data;
        assert(inst != NULL);

        /* Check if the current instruction is  *
         * an exit point of the loop		*/
        if (LOOPS_isAnExitInstruction(loop, inst)) {
            xanList_append(loop->exits, inst);
        }

        /* Fetch the next element from the list	*/
        item = item->next;
    }

    /* Return				*/
    return JITTRUE;
}

static inline JITBOOLEAN internal_whilify (XanHashTable *loops, loop_t *loop) {
    t_loop_extended         *current_loop;
    XanList                 *toDelete;
    XanListItem             *item;
    JITBOOLEAN transformed;

    /* Assertions				*/
    assert(loop != NULL);

    /* Initialize the variables		*/
    transformed = JITFALSE;

    /* Allocate resources for the extended	*
     * loop data structure			*/
    current_loop = allocFunction(sizeof(t_loop_extended));
    assert(current_loop != NULL);

    /* Get current loop			*/
    current_loop->loop = loop;

    /* Get parent loop			*/
    current_loop->parent_loop = LOOPS_getParentLoopWithinMethod(loops, loop);

    /* Get the loop header			*/
    current_loop->loop_head = loop->header;

    /* Get the list of loop instructions	*/
    current_loop->loop_instructions = xanList_cloneList(loop->instructions);
    toDelete = xanList_new(allocFunction, freeFunction, NULL);
    item = xanList_first(current_loop->loop_instructions);
    while (item != NULL) {
        ir_instruction_t        *inst;
        inst = item->data;
        assert(inst != NULL);
        if (!IRMETHOD_doesInstructionBelongToMethod(loop->method, inst)) {
            xanList_append(toDelete, inst);
        }
        item = item->next;
    }
    item = xanList_first(toDelete);
    while (item != NULL) {
        xanList_removeElement(current_loop->loop_instructions, item->data, JITTRUE);
        item = item->next;
    }

    /* Identify back edges.			*
     * A loop is being considered: one back	*
     * edge should be present, at least	*/
    current_loop->loop_back_edges = LOOPS_getBackedges(loop);
    assert(current_loop->loop_back_edges != NULL);
    assert(xanList_length(current_loop->loop_back_edges) > 0);

    /* Get the loop exits			*/
    current_loop->loop_exits = xanList_cloneList(loop->exits);
    assert(current_loop->loop_exits != NULL);

    /* Check the type of the loop		*/
    internal_checkLoop(loop->method, current_loop);
    assert(LOOP_UNKNOWN != current_loop->loop_type);

    /* Act according to the validity and	*
     * type of the loop			*/
    if (LOOP_DOWHILE == current_loop->loop_type) {

        /* Get the instruction where the loop   *
         * condition evaluation starts		*/
        internal_findLoopCondition(loop->method, current_loop);

        /* Unroll one iteration of the loop	*/
        internal_addInstructions(current_loop);
        transformed = JITTRUE;
    }

    /* Free the memory			*/
    xanList_destroyList(current_loop->loop_back_edges);
    xanList_destroyList(current_loop->loop_exits);
    xanList_destroyList(current_loop->loop_instructions);
    freeFunction(current_loop);
    xanList_destroyList(toDelete);

    /* Return				*/
    return transformed;
}

static inline void internal_checkLoop (ir_method_t * method, t_loop_extended * current_loop) {
    XanList                 *work_list;
    XanList                 *backedges;
    XanListItem             *item;
    XanListItem             *temp_item, *bis_item;
    XanNode                 *temp_node;
    ir_instruction_t        *temp_inst;
    ir_instruction_t        *parent_inst;
    ir_instruction_t        *matched_inst;
    IRBasicBlock              *BB_temp;
    JITUINT32 matching_inst;

    /* Initialize the variables			*/
    matched_inst = NULL;
    parent_inst = NULL;

    // If current and parent loops share the same header, then the loop to be examined is the parent
    if (NULL != current_loop->parent_loop && current_loop->loop->header == current_loop->parent_loop->header) {
        current_loop->loop_type = LOOP_NESTED;
        return;
    }

    // Check if the loop is generated by a catcher routine
    if (IRSTARTCATCHER == IRMETHOD_getInstructionType(current_loop->loop_head)) {
        current_loop->loop_type = LOOP_CATCHER;
        return;
    }

    // Similarly all loop exits must be branchif or branchifnot...
    temp_item = current_loop->loop_exits->firstItem;
    while (temp_item != NULL) {
        if (IRBRANCHIF == IRMETHOD_getInstructionType((ir_instruction_t*) temp_item->data) || IRBRANCHIFNOT == IRMETHOD_getInstructionType((ir_instruction_t*) temp_item->data)) {
            temp_item = temp_item->next;
        } else {
            current_loop->loop_type = LOOP_MALFORMED;
            return;
        }
    }

    // ... the same the back edges
    temp_item = current_loop->loop_back_edges->firstItem;
    while (temp_item != NULL) {
        if (IRBRANCHIF == IRMETHOD_getInstructionType((ir_instruction_t*) temp_item->data) || IRBRANCHIFNOT == IRMETHOD_getInstructionType((ir_instruction_t*) temp_item->data)) {
            temp_item = temp_item->next;
        } else {
            current_loop->loop_type = LOOP_MALFORMED;
            return;
        }
    }

    matching_inst = 0;
    temp_item = current_loop->loop_back_edges->firstItem;
    while (NULL != temp_item) {
        temp_inst = (ir_instruction_t*) temp_item->data;
        if (NULL != xanList_find(current_loop->loop_exits, temp_inst)) {
            matched_inst = temp_inst;
            matching_inst++;
        } else if (NULL != xanList_find(current_loop->loop_exits, IRMETHOD_getPrevInstruction(method, temp_inst))) {
            matched_inst = temp_inst;
            matching_inst++;
        } else if (NULL != xanList_find(current_loop->loop_exits, IRMETHOD_getNextInstruction(method, temp_inst))) {
            matched_inst = IRMETHOD_getNextInstruction(method, temp_inst);
            matching_inst++;
        }
        temp_item = temp_item->next;
    }

    // If no matching instructions, the loop is a while/for one
    if (0 == matching_inst) {
        current_loop->loop_type = LOOP_WHILE;
        return;
    }

    // If two or more matching instructions, the loop shows an odd combination of consecutive break & continue
    if (2 <= matching_inst) {
        current_loop->loop_type = LOOP_ODD;
        return;
    }

    // If the matched instruction isn't a leaf in the predominance tree, the loop must be a while/for with an odd break & continue
    temp_node = method->preDominatorTree->find(method->preDominatorTree, matched_inst);
    assert(NULL != temp_node);
    if (NULL != temp_node->childrens && xanList_length(temp_node->childrens) > 0) {
        temp_item = temp_node->childrens->firstItem;
        while (NULL != temp_item) {
            if (NULL != xanList_find(current_loop->loop_instructions, (ir_instruction_t*) temp_item->data)) {
                current_loop->loop_type = LOOP_ODD;
                return;
            }
            temp_item = temp_item->next;
        }
    }

    // Clone the loop exits' list into a working list
    work_list = xanList_cloneList(current_loop->loop_exits);
    assert(xanList_length(work_list) >= 1);

    // Append the list of back edges to the working list
    xanList_appendList(work_list, current_loop->loop_back_edges);
    assert(xanList_length(work_list) >= 2);
    assert(xanList_length(work_list) > xanList_length(current_loop->loop_back_edges));

    // Perform a duplicates' cleanup inside the working list
    xanList_deleteClones(work_list);

    // Initialise temp_inst to point the previously matched instruction
    temp_inst = matched_inst;

    // Starting from the previously matched instruction, go back up the dominator tree until neither a BE nor LE is found
    while (JITTRUE) {

        // Get the first instruction in the current Basic Block
        BB_temp = IRMETHOD_getBasicBlockContainingInstruction(method, temp_inst);
        temp_inst = IRMETHOD_getInstructionAtPosition(method, BB_temp->startInst);

        // Break if reached the header of the loop
        if (temp_inst == current_loop->loop_head) {
            break;
        }

        // Get the corresponding node in the dominator tree, then its (unique) parent
        temp_node = method->preDominatorTree->find(method->preDominatorTree, temp_inst);
        assert(NULL != temp_node);
        temp_node = temp_node->parent;
        assert(NULL != temp_node);

        // Get the corresponding instruction, that belongs to a different Basic Block
        parent_inst = (ir_instruction_t*) temp_node->data;
        assert(BB_temp != IRMETHOD_getBasicBlockContainingInstruction(method, parent_inst));

        // If the instruction is a jump to BE/LE and is dominated by a LE/BE (not examined, yet), then skip to the previous dominator
        while (NULL == xanList_find(work_list, parent_inst) && IRMETHOD_mayHaveNotFallThroughInstructionAsSuccessor(method, parent_inst)) {
            BB_temp = IRMETHOD_getBasicBlockContainingInstruction(method, parent_inst);
            parent_inst = IRMETHOD_getInstructionAtPosition(method, BB_temp->startInst);
            if (parent_inst == current_loop->loop_head) {
                break;
            }
            temp_node = method->preDominatorTree->find(method->preDominatorTree, parent_inst);
            assert(NULL != temp_node);
            temp_node = temp_node->parent;
            assert(NULL != temp_node);
            parent_inst = (ir_instruction_t*) temp_node->data;
            assert(BB_temp != IRMETHOD_getBasicBlockContainingInstruction(method, parent_inst));
        }

        // If the instruction is in the working list (BE or LE, then a jump), remove it and continue, else break search since found what needed
        if (NULL != xanList_find(work_list, parent_inst)) {
            assert(IRMETHOD_mayHaveNotFallThroughInstructionAsSuccessor(method, parent_inst));
            xanList_removeElement(work_list, parent_inst, JITTRUE);
            temp_inst = parent_inst;
        } else {
            break;
        }
    }

    // Search inside working list for any node dominated by the found one, then delete what found
    temp_item = work_list->lastItem;
    while (temp_item != NULL) {
        if (IRMETHOD_isInstructionAPredominator(method, temp_inst, (ir_instruction_t*) temp_item->data)) {
            bis_item = temp_item;
            temp_item = temp_item->prev;
            xanList_deleteItem(work_list, bis_item);
        } else {
            temp_item = temp_item->prev;
        }
    }

    // If working list isn't empty, it means than there's some break/continue somewhere else that cannot be handled
    if (xanList_length(work_list) > 0) {
        if (xanList_length(work_list) == 1) {
            current_loop->loop_type = LOOP_DOWHILE_JUMP;
        } else {
            current_loop->loop_type = LOOP_JUMPS;
        }

        /* Free the memory			*/
        xanList_destroyList(work_list);

        /* Return				*/
        return;
    }
    assert(xanList_length(work_list) == 0);

    /* Free the memory			*/
    xanList_destroyList(work_list);

    // Check if the loop is made of only one basic block
    if (IRMETHOD_getBasicBlockContainingInstruction(method, current_loop->loop_head) == IRMETHOD_getBasicBlockContainingInstruction(method, matched_inst)) {
        current_loop->loop_type = LOOP_ONE_BLOCK;
    }

    // If the found Basic Block is the same as the loop header belongs to the loop is not valid
    if (LOOP_ONE_BLOCK != current_loop->loop_type && IRMETHOD_getBasicBlockContainingInstruction(method, temp_inst) == IRMETHOD_getBasicBlockContainingInstruction(method, current_loop->loop_head)) {
        current_loop->loop_type = LOOP_UNSUPPORTED;
        return;
    }

    // Found instruction must dominate all the loop exits...
    temp_item = current_loop->loop_exits->firstItem;
    while (temp_item != NULL) {
        if (IRMETHOD_isInstructionAPredominator(method, temp_inst, (ir_instruction_t*) temp_item->data)) {
            temp_item = temp_item->next;
        } else {
            current_loop->loop_type = LOOP_WRONG;
            return;
        }
    }

    // ... and all the back edges
    temp_item = current_loop->loop_back_edges->firstItem;
    while (temp_item != NULL) {
        if (!IRMETHOD_isInstructionAPredominator(method, temp_inst, (ir_instruction_t *) temp_item->data)) {
            current_loop->loop_type = LOOP_WRONG;
            return;
        }
        temp_item = temp_item->next;
    }

    // If execution reached this point, the loop is a do-while
    current_loop->loop_type = LOOP_DOWHILE;

    /* Fetch the instruction that compute the	*
     * condition of the loop			*/
    current_loop->BB_cond_inst = NULL;
    backedges = LOOPS_getBackedges(current_loop->loop);
    assert(backedges != NULL);
    item = xanList_first(backedges);
    while (item != NULL) {
        ir_instruction_t        *backedge;
        backedge = (ir_instruction_t *) item->data;
        assert(backedge != NULL);
        if (    (current_loop->BB_cond_inst == NULL)                                                    ||
                (IRMETHOD_isInstructionAPredominator(method, current_loop->BB_cond_inst, backedge))     ) {
            current_loop->BB_cond_inst = backedge;
        }
        assert(current_loop->BB_cond_inst != NULL);
        item = item->next;
    }
    assert(current_loop->BB_cond_inst != NULL);

    /* Free the memory				*/
    xanList_destroyList(backedges);

    /* Return					*/
    return;
}

static inline void internal_findLoopCondition (ir_method_t * method, t_loop_extended * current_loop) {
    XanStack                *work_stack;
    ir_instruction_t        *temp_inst;
    ir_item_t               *param;
    JITUINT32 varID;
    JITBOOLEAN var_miss, shift_inst;
    IRBasicBlock              *bb;

    /* Assertions					*/
    assert(method != NULL);
    assert(current_loop != NULL);

    // Allocate space for a new working stack
    work_stack = xanStack_new(allocFunction, freeFunction, NULL);
    assert(NULL != work_stack);

    // Start from the last instruction in the Basic Block
    bb = IRMETHOD_getBasicBlockContainingInstruction(method, current_loop->BB_cond_inst);
    temp_inst = IRMETHOD_getInstructionAtPosition(method, bb->endInst);
    assert(IRMETHOD_mayHaveNotFallThroughInstructionAsSuccessor(method, temp_inst));
    assert(IRBRANCHIF == IRMETHOD_getInstructionType(temp_inst) || IRBRANCHIFNOT == IRMETHOD_getInstructionType(temp_inst));

    // Initialise the stack with the ID of the branch variable
    param = IRMETHOD_getInstructionParameter1(temp_inst);
    assert(IROFFSET == param->type);
    xanStack_push(work_stack, (void*) (JITNUINT) (param->value).v);

    // Now stack cannot be empty
    assert(xanStack_getSize(work_stack) > 0);

    // No variable miss and no need to shift any instruction, yet
    var_miss = JITFALSE;
    shift_inst = JITFALSE;

    // Start searching: iterate till the beginning of the basic block is reached or the working stack is empty
    bb = IRMETHOD_getBasicBlockContainingInstruction(method, current_loop->BB_cond_inst);
    while (temp_inst != IRMETHOD_getInstructionAtPosition(method, bb->startInst) && xanStack_getSize(work_stack) > 0) {

        // Get previous instruction
        if (var_miss == JITFALSE) {
            temp_inst = IRMETHOD_getPrevInstruction(method, temp_inst);
        }

        // Pop the top of the stack
        varID = (IR_ITEM_VALUE) (JITNUINT) xanStack_pop(work_stack);

        // Check instruction type and act consequently
        switch (IRMETHOD_getInstructionType(temp_inst)) {

                // Comparison
            case IRLT:
            case IRGT:
            case IREQ:
                // Logical operations
            case IRAND:
            case IROR:
            case IRXOR:
                // Arithmetic instruction
            case IRADD:
            case IRADDOVF:
            case IRSUB:
            case IRSUBOVF:
            case IRMUL:
            case IRMULOVF:
            case IRDIV:
                assert(IROFFSET == IRMETHOD_getInstructionResult(temp_inst)->type);
                param = IRMETHOD_getInstructionResult(temp_inst);
                // Following if statement is not true if some optimisation is performed before the execution of the plugin
                if (varID == (JITNUINT) (param->value).v) {
                    var_miss = JITFALSE;
                    // If first parameter is a variable, then get its ID and push to the stack
                    param = IRMETHOD_getInstructionParameter1(temp_inst);
                    if (IROFFSET == param->type && IRMETHOD_isTheVariableATemporary(method, (param->value).v)) {
                        xanStack_push(work_stack, (void*) (JITNUINT) (param->value).v);
                    }
                    // If second parameter is a variable, then get its ID and push to the stack
                    param = IRMETHOD_getInstructionParameter2(temp_inst);
                    if (IROFFSET == param->type && IRMETHOD_isTheVariableATemporary(method, (param->value).v)) {
                        xanStack_push(work_stack, (void*) (JITNUINT) (param->value).v);
                    }
                } else {
                    if (0 == xanStack_getSize(work_stack)) {
                        shift_inst = JITTRUE;
                    }
                    var_miss = JITTRUE;
                }
                break;

                // Conversion
            case IRCONV:
                // Logical operations
            case IRNOT:
            case IRNEG:
                // Load rel
            case IRLOADREL:

                assert(IROFFSET == IRMETHOD_getInstructionResult(temp_inst)->type);
                param = IRMETHOD_getInstructionResult(temp_inst);
                // Following if statement is not true if some optimisation is performed before the execution of the plugin
                if (varID == (JITNUINT) (param->value).v) {
                    var_miss = JITFALSE;
                    // If first parameter is a variable (others aren't), then get its ID and push to the stack
                    param = IRMETHOD_getInstructionParameter1(temp_inst);
                    if (IROFFSET == param->type && IRMETHOD_isTheVariableATemporary(method, (param->value).v)) {
                        xanStack_push(work_stack, (void*) (JITNUINT) (param->value).v);
                    }
                } else {
                    if (0 == xanStack_getSize(work_stack)) {
                        shift_inst = JITTRUE;
                    }
                    var_miss = JITTRUE;
                }
                break;

                // Move
            case IRMOVE:

                param = IRMETHOD_getInstructionResult(temp_inst);
                if (IROFFSET == param->type && varID == (JITNUINT) (param->value).v) {
                    var_miss = JITFALSE;
                    // If second parameter is a variable (others aren't meaningful), then get its ID and push to the stack
                    param = IRMETHOD_getInstructionParameter1(temp_inst);
                    if (IROFFSET == param->type && IRMETHOD_isTheVariableATemporary(method, (param->value).v)) {
                        xanStack_push(work_stack, (void*) (JITNUINT) (param->value).v);
                    }
                } else {
                    if (0 == xanStack_getSize(work_stack)) {
                        shift_inst = JITTRUE;
                    }
                    var_miss = JITTRUE;
                }
                break;

                // None of previous
            default:
                if (0 == xanStack_getSize(work_stack)) {
                    shift_inst = JITTRUE;
                }
                var_miss = JITTRUE;
                break;
        }
        bb = IRMETHOD_getBasicBlockContainingInstruction(method, current_loop->BB_cond_inst);
    }

    // Shift instruction by one, if a miss happened
    if (shift_inst == JITTRUE) {
        temp_inst = IRMETHOD_getNextInstruction(method, temp_inst);
    }

    // Destroy no longer used stack
    xanStack_destroyStack(work_stack);

    // Now temp_inst is the first instruction of condition evaluation
    assert(temp_inst != current_loop->loop_head);

    // If previous instruction is a label, then move temp_inst to it
    // Repeat until inside the BB, but hopefully this step will run only once
    bb = IRMETHOD_getBasicBlockContainingInstruction(method, current_loop->BB_cond_inst);
    while (temp_inst != IRMETHOD_getInstructionAtPosition(method, bb->startInst) && IRLABEL == IRMETHOD_getInstructionType(IRMETHOD_getPrevInstruction(method, temp_inst))) {
        temp_inst = IRMETHOD_getPrevInstruction(method, temp_inst);
        bb = IRMETHOD_getBasicBlockContainingInstruction(method, current_loop->BB_cond_inst);
    }

    current_loop->loop_cond = temp_inst;
}

static inline void internal_addInstructions (t_loop_extended *current_loop) {
    XanList                 *loop_labels;
    XanListItem             *item;
    ir_instruction_t        *loop_prehead, *last_cloned, *inst;
    IR_ITEM_VALUE label_cond;
    IR_ITEM_VALUE label_postprehead;
    IR_ITEM_VALUE deltaLabelsID;
    ir_method_t             *method;

    /* Assertions						*/
    assert(current_loop != NULL);
    assert(current_loop->loop_cond != NULL);
    assert(current_loop->loop_head != NULL);
    assert(current_loop->loop_instructions != NULL);
    assert(xanList_find(current_loop->loop_instructions, current_loop->loop_cond) != NULL);

    /* Initialize the variables				*/
    label_cond = 0;
    label_postprehead = 0;

    /* Fetch the IR method					*/
    method = current_loop->loop->method;
    assert(method != NULL);

    /* Fetch the label that identify where the loop         *
     * condition is checked					*/
    if (IRMETHOD_getInstructionType(current_loop->loop_cond) != IRLABEL) {
        label_cond = IRMETHOD_newLabelID(method);
        inst = IRMETHOD_newInstructionBefore(method, current_loop->loop_cond);
        IRMETHOD_setInstructionType(method, inst, IRLABEL);
        IRMETHOD_setInstructionParameter1(method, inst, label_cond, 0, IRLABELITEM, IRLABELITEM, NULL);
        current_loop->loop_cond = inst;
        assert(IRLABEL == IRMETHOD_getInstructionType(current_loop->loop_cond));
        xanList_append(current_loop->loop_instructions, current_loop->loop_cond);
    }
    assert(IRMETHOD_getInstructionType(current_loop->loop_cond) == IRLABEL);

    /* Add the preheader					*
     * The pre-header contains redundant branches, in order	*
     * to keep a clean and immediate view in the control    *
     * flow graph.						*
     * Such branches will be deleted, if needed, by a       *
     * specific plugin					*/
    loop_prehead = LOOPS_addPreHeader(current_loop->loop, NULL);
    assert(loop_prehead != NULL);
    assert(loop_prehead->type == IRLABEL);

    /* Add the label after the label of the pre-header, but	*
     * still within the pre-header basic block		*/
    inst = IRMETHOD_newInstructionAfter(method, loop_prehead);
    IRMETHOD_setInstructionType(method, inst, IRLABEL);
    label_postprehead = IRMETHOD_newLabelID(method);
    IRMETHOD_setInstructionParameter1(method, inst, label_postprehead, 0, IRLABELITEM, IRLABELITEM, NULL);

    /* Add the jump to the condition evaluation of the loop	*/
    inst = IRMETHOD_newInstructionAfter(method, inst);
    IRMETHOD_setInstructionType(method, inst, IRBRANCH);
    IRMETHOD_setInstructionParameter1(method, inst, label_cond, 0, IRLABELITEM, IRLABELITEM, NULL);

    /* Compute the list of labels of the loop		*/
    loop_labels = xanList_new(allocFunction, freeFunction, NULL);
    assert(loop_labels != NULL);
    item = xanList_first(current_loop->loop_instructions);
    while (item != NULL) {
        inst = (ir_instruction_t *) item->data;
        assert(inst != NULL);
        if (inst->type == IRLABEL) {
            xanList_append(loop_labels, inst);
        }
        item = item->next;
    }

    /* Compute the label delta to add of labels of the first*
     * iteration of the loop, which will be pilled out	*/
    deltaLabelsID = IRMETHOD_getMaxLabelID(current_loop->loop->method) + 1;

    /* Order the list from the lowest to the highest ID	*/
    LOOPS_sortInstructions(method, current_loop->loop_instructions, current_loop->loop->header);

    /* Peel out the first iteration of the loop		*/
    assert(IRLABEL == IRMETHOD_getInstructionType(current_loop->loop_head));
    last_cloned = loop_prehead;
    item = xanList_first(current_loop->loop_instructions);
    while (item != NULL) {
        ir_instruction_t        *temp_inst;
        XanListItem             *item2;

        /* Fetch the instruction			*/
        inst = (ir_instruction_t*) item->data;
        assert(inst != NULL);

        /* Check if the instruction is the one that exit*
         * from the loop eventually			*/
        if (inst == current_loop->loop_cond) {

            /* Add the branch to the beginning of the while	*
             * loop						*/
            last_cloned = IRMETHOD_newInstructionAfter(method, last_cloned);
            IRMETHOD_setInstructionType(method, last_cloned, IRBRANCH);
            IRMETHOD_setInstructionParameter1(method, last_cloned, label_postprehead, 0, IRLABELITEM, IRLABELITEM, NULL);

            /* Fetch the next element from the list		*/
            item = item->next;
            continue;
        }

        /* Clone the instruction                        */
        temp_inst = IRMETHOD_cloneInstruction(method, inst);
        assert(temp_inst != NULL);

        /* Move the instruction after the last cloned	*
         * instruction					*/
        IRMETHOD_moveInstructionAfter(method, temp_inst, last_cloned);
        last_cloned = temp_inst;

        /* If the instruction has a LABELITEM as a      *
         * parameter, which was part of the loop, then	*
         * we need to rename it				*/
        item2 = xanList_first(loop_labels);
        while (item2 != NULL) {
            ir_instruction_t        *label;
            IR_ITEM_VALUE oldLabelID;
            label = item2->data;
            assert(label != NULL);
            oldLabelID = IRMETHOD_getInstructionParameter1Value(label);
            IRMETHOD_substituteLabel(current_loop->loop->method, last_cloned, oldLabelID, oldLabelID + deltaLabelsID);
            item2 = item2->next;
        }

        /* Fetch the next element from the list		*/
        item = item->next;
    }

    /* Fix the backedges				*/
    LOOPS_adjustLoopToHaveOneBackedge(current_loop->loop);

    /* Free the memory				*/
    xanList_destroyList(loop_labels);

    /* Return					*/
    return;
}

ir_instruction_t * LOOPS_addPreHeader (loop_t *loop, XanList *predecessors) {
    ir_instruction_t *firstInst;
    JITBOOLEAN toDelete;

    /* Assertions					*/
    assert(loop != NULL);

    /* Fetch the predecessors of the header		*/
    toDelete = JITFALSE;
    if (predecessors == NULL) {
        predecessors = IRMETHOD_getInstructionPredecessors(loop->method, loop->header);
        toDelete = JITTRUE;
    }
    assert(predecessors != NULL);

    /* Add the pre-header				*/
    firstInst = internal_LOOPS_addPreHeader(loop, predecessors);
    assert(firstInst != NULL);

    /* Free the memory 				*/
    if (toDelete) {
        xanList_destroyList(predecessors);
    }

    /* Return					*/
    return firstInst;
}

static inline ir_instruction_t * internal_LOOPS_addPreHeader (loop_t *loop, XanList *predecessors) {
    IR_ITEM_VALUE label_head;
    IR_ITEM_VALUE label_prehead;
    ir_instruction_t        *inst;
    ir_instruction_t        *loop_prehead;
    ir_instruction_t        *branch;
    XanListItem *item;

    /* Assertions					*/
    assert(loop != NULL);
    assert(IRMETHOD_getInstructionType(loop->header) == IRLABEL);

    /* Fetch the label of the header		*/
    label_head = IRMETHOD_getInstructionParameter1Value(loop->header);

    /* Add the label for the pre-header		*/
    label_prehead = IRMETHOD_newLabelID(loop->method);
    assert(label_prehead != label_head);

    /* Point the predecessors of the header, which	*
     * do not belong to the loop, to the		*
     * pre-header					*/
    item = xanList_first(predecessors);
    while (item != NULL) {
        inst = item->data;
        assert(inst != NULL);
        if (xanList_find(loop->instructions, inst) == NULL) {

            /* That is, if inst is outside the loop then it must be updated to	*
             * point to the pre-header						*/
            IRMETHOD_substituteLabel(loop->method, inst, label_head, label_prehead);
        }
        item = item->next;
    }

    /* Add the pre-header				*/
    loop_prehead = IRMETHOD_newInstructionBefore(loop->method, loop->header);
    IRMETHOD_setInstructionType(loop->method, loop_prehead, IRLABEL);
    IRMETHOD_setInstructionParameter1(loop->method, loop_prehead, label_prehead, 0, IRLABELITEM, IRLABELITEM, NULL);
    branch = IRMETHOD_newBranchToLabel(loop->method, loop->header);
    IRMETHOD_moveInstructionAfter(loop->method, branch, loop_prehead);

    /* Return					*/
    return loop_prehead;
}

void LOOPS_adjustLoopToHaveOneBackedge (loop_t *loop) {
    XanList                 *l;
    ir_instruction_t        *backedge;

    /* Assertions				*/
    assert(loop != NULL);
    assert(loop->header != NULL);
    assert(loop->header->type == IRLABEL);
    assert(loop->instructions != NULL);
    assert(xanList_length(loop->instructions) > 0);

    /* Fetch the list of backedges		*/
    l = LOOPS_getBackedges(loop);
    assert(l != NULL);
    assert(xanList_length(l) >= 1);
    backedge = (ir_instruction_t *) xanList_first(l)->data;
    assert(backedge != NULL);

    /* Adjust the code			*/
    if (    (xanList_length(l) > 1)              ||
            (backedge->type != IRBRANCH)    ) {
        ir_instruction_t        *label;
        ir_instruction_t        *branch;
        IR_ITEM_VALUE oldLabel;
        IR_ITEM_VALUE newLabel;
        XanListItem             *item;

        /* Fetch the label of the entry point	*
         * of the method			*/
        oldLabel = IRMETHOD_getInstructionParameter1Value(loop->header);

        /* Add a new basic block at the end of	*
         * the loop				*/
        label = IRMETHOD_newLabel(loop->method);
        assert(label != NULL);
        newLabel = IRMETHOD_getInstructionParameter1Value(label);
        branch = IRMETHOD_newBranchToLabel(loop->method, loop->header);
        assert(branch != NULL);
        assert(xanList_find(l, branch) == NULL);
        xanList_append(loop->instructions, label);
        xanList_append(loop->instructions, branch);

        /* Change the backedge to jump to the	*
         * new basic block, which then become	*
         * the unique back-edge of the loop	*/
        item = xanList_first(l);
        while (item != NULL) {
            ir_instruction_t        *inst;
            ir_instruction_t        *newbranch;

            /* Fetch the instruction		*/
            inst = item->data;
            assert(inst != NULL);

            /* Adjust the backedge			*/
            switch (inst->type) {
                case IRBRANCH:
                case IRBRANCHIF:
                case IRBRANCHIFNOT:
                    IRMETHOD_substituteLabel(loop->method, inst, oldLabel, newLabel);
                    break;
                default:
                    newbranch = IRMETHOD_newBranchToLabel(loop->method, label);
                    IRMETHOD_moveInstructionAfter(loop->method, newbranch, inst);
                    xanList_append(loop->instructions, newbranch);
            }

            /* Fetch the next element of the list	*/
            item = item->next;
        }
    }

    /* Free the memory			*/
    xanList_destroyList(l);

    /* Check the loop			*/
#ifdef DEBUG
    l = LOOPS_getBackedges(loop);
    assert(l != NULL);
    assert(xanList_length(l) == 1);
    backedge = (ir_instruction_t *) xanList_first(l)->data;
    assert(backedge != NULL);
    assert(backedge->type == IRBRANCH);
    assert(IRMETHOD_getSuccessorInstruction(loop->method, backedge, NULL) == loop->header);
    xanList_destroyList(l);
#endif

    /* Return				*/
    return;
}

void LOOPS_peelOutFirstIteration (loop_t *loop) {

    /* Assertions				*/
    assert(loop != NULL);

    /* Peel the loop			*/
    internal_peelLoopStart(loop->method, loop, 1);

    /* Return				*/
    return ;
}

/**
 * Peel off a number of iterations from the start of a loop.
 */
static inline void internal_peelLoopStart(ir_method_t *method, loop_t *loop, JITUINT32 numIter) {
    JITUINT32 iter;
    ir_instruction_t *firstLoopInst;
    XanList *loopInsts;
    XanList *orderedLoopInsts;

    /* Get the loop's header label. */
    firstLoopInst = loop->header;
    assert(firstLoopInst->type == IRLABEL);

    /* Get all loop instructions before anything is changed. */
    loopInsts = xanList_cloneList(loop->instructions);
    assert(loopInsts != NULL);

    /* Order the loop instructions. */
    orderedLoopInsts = internal_getOrderedLoopInsts(method, firstLoopInst, loopInsts);

    /* Simply peel of one iteration after another. */
    assert(numIter == 1);
    for (iter = 0; iter < numIter; ++iter) {
        XanList *peeledInsts;
        XanList *outLabels;

        /* Get a list of target labels for branches that leave the loop. */
        outLabels = internal_getOutLabels(method, orderedLoopInsts);

        /* Create new instructions in the method. */
        peeledInsts = internal_peelOneIteration(method, orderedLoopInsts);

        /* Fix up labels. */
        fixLabels(method, peeledInsts, outLabels);

        /* Make non-loop predecessors point to the peeled iteration. */
        patchLoopPreds(method, orderedLoopInsts, peeledInsts);

        /* Clean up. */
        xanList_destroyList(peeledInsts);
        xanList_destroyListAndData(outLabels);
    }

    /* Clean up. */
    xanList_destroyList(loopInsts);
    xanList_destroyList(orderedLoopInsts);
}

/**
 * Get a list of loop instructions that is ordered so that only the first
 * instruction (the entry instruction) occurs before its loop predecessors.
 * In addition, preserve the fall-through edges from the control-flow graph
 * in the list ordering.  This means that when there are two instructions, A
 * and B, where B follows A in the control flow graph and A is not a control
 * transfer instruction or B is not the target of A, then B should immediately
 * follow A in the new list.
 */
static inline XanList * internal_getOrderedLoopInsts(ir_method_t *method, ir_instruction_t *firstLoopInst, XanList *loopInsts) {
    XanList *orderedInsts;
    XanListItem *currInst;

    /* Initialise the structures. */
    orderedInsts = xanList_new(allocFunction, freeFunction, NULL);

    /* Start with the loop header instruction. */
    xanList_append(orderedInsts, firstLoopInst);

    /* Check each instruction already in the worklist. */
    currInst = xanList_first(orderedInsts);
    while (currInst) {
        ir_instruction_t *inst;
        ir_instruction_t *succ;

        /* Check that each successor has been added. */
        succ = NULL;
        inst = xanList_getData(currInst);
        while ((succ = IRMETHOD_getSuccessorInstruction(method, inst, succ))) {
            if (!xanList_find(orderedInsts, succ) &&
                    xanList_find(loopInsts, succ)) {
                xanList_append(orderedInsts, succ);
                addFallThroughInstsToList(method, loopInsts, orderedInsts, succ);
            }
        }

        /* Next instruction in list. */
        currInst = currInst->next;
    }

    /* Check the new list and return it. */
    assert(xanList_length(orderedInsts) == xanList_length(loopInsts));
    return orderedInsts;
}

/**
 * Get target labels for branches that leave a loop.  If a branch leaves the
 * loop but the target does not have a label then create a new one for it.
 */
static inline XanList * internal_getOutLabels(ir_method_t *method, XanList *loopInsts) {
    XanList *outLabels;
    XanListItem *currInst;

    /* Check all branch successors to see if they are in the loop. */
    currInst = xanList_first(loopInsts);
    outLabels = xanList_new(allocFunction, freeFunction, NULL);
    while (currInst) {
        ir_instruction_t *inst = xanList_getData(currInst);
        if (inst->type == IRBRANCHIF || inst->type ==  IRBRANCHIFNOT) {
            getBranchOutLabels(method, inst, loopInsts, outLabels);
        }
        currInst = currInst->next;
    }

    /* Return the labels. */
    return outLabels;
}

/**
 * Peel off a single iteration from a loop.  To do this iterate over all
 * basic blocks in the loop, duplicating each instruction in them.  At each
 * conditional branch encountered, check whether it leaves the loop and if
 * so, fix up the labels and branch type to maintain correct control flow.
 */
static inline XanList * internal_peelOneIteration(ir_method_t *method, XanList *loopInsts) {
    XanList *peeledInsts;
    XanListItem *currInst;

    /* Clone each instruction and save it in the list. */
    currInst = xanList_first(loopInsts);
    peeledInsts = xanList_new(allocFunction, freeFunction, NULL);
    while (currInst) {
        ir_instruction_t *inst;
        ir_instruction_t *clone;

        /* Clone the instruction. */
        inst = xanList_getData(currInst);
        clone = IRMETHOD_cloneInstruction(method, inst);

        /* Fix up conditional branches so their targets are correct. */
        if (inst->type == IRBRANCHIF || inst->type ==  IRBRANCHIFNOT) {
            fixClonedBranch(method, inst, clone, loopInsts);
        }

        /* Add to the list. */
        xanList_append(peeledInsts, clone);
        currInst = currInst->next;
    }

    /* Return the newly-created instructions. */
    return peeledInsts;
}

/**
 * Fix labels within the list of peeled instructions.  This is achieved by
 * renaming all labels so that they are unique to the peeled iteration.
 * Labels are only renamed if they are from the original loop, rather than
 * outside the loop, and as long as they don't point back to the start of
 * the loop.
 */
static inline void fixLabels(ir_method_t *method, XanList *peeledInsts, XanList *outLabels) {
    XanListItem *currInst;
    XanHashTable *labelMap;
    ir_instruction_t *firstInst;
    IR_ITEM_VALUE firstLabel;
    JITUINT32 i;

    /* Initialise a map from old label to new label. */
    labelMap = xanHashTable_new(xanList_length(peeledInsts), JITFALSE, allocFunction, reallocFunction, freeFunction, valuePtrHash, valuePtrsMatch);

    /* Get the first instruction (which should be a label). */
    currInst = xanList_first(peeledInsts);
    firstInst = xanList_getData(currInst);
    assert(firstInst->type == IRLABEL);

    /* Change the label value for this instruction. */
    firstLabel = IRMETHOD_getInstructionParameter1Value(firstInst);
    xanHashTable_insert(labelMap, createValuePtr(firstLabel), createValuePtr(firstLabel));
    IRMETHOD_setInstructionParameter1Value(method, firstInst, IRMETHOD_newLabelID(method));
    xanList_deleteItem(peeledInsts, currInst);

    /* Do two passes, labels first time, branches second. */
    for (i = 0; i < 2; ++i) {

        /* Iterate over all instructions. */
        currInst = xanList_first(peeledInsts);
        while (currInst) {
            ir_item_t *param;
            ir_instruction_t *inst;

            /* Label parameter depends on instruction type. */
            inst = xanList_getData(currInst);
            switch (inst->type) {
                case IRLABEL:
                    if (i == 0) {
                        param = IRMETHOD_getInstructionParameter1(inst);
                        translateLabel(method, param, labelMap, outLabels);
                    }
                    break;
                case IRBRANCH:
                    if (i == 1) {
                        param = IRMETHOD_getInstructionParameter1(inst);
                        translateLabel(method, param, labelMap, outLabels);
                    }
                    break;
                case IRBRANCHIF:
                case IRBRANCHIFNOT:
                    if (i == 1) {
                        param = IRMETHOD_getInstructionParameter2(inst);
                        translateLabel(method, param, labelMap, outLabels);
                    }
                    break;
            }

            /* Next instruction. */
            currInst = currInst->next;
        }
    }

    /* Clean up. */
    xanHashTable_destroyTableAndKey(labelMap);
    xanList_insert(peeledInsts, firstInst);
}

/**
 * Patch up the predecessor instructions of the original loop so that they
 * point to the peeled iteration.  Predecessor instructions are the
 * predecessors of the loop that are not also in the loop and are not in the
 * peeled iteration either.
 */
static inline void patchLoopPreds(ir_method_t *method, XanList *loopInsts, XanList *peeledInsts) {
    ir_instruction_t *pred;
    ir_instruction_t *firstLoop;
    ir_instruction_t *firstPeeled;
    XanListItem *currLoopInst;
    XanListItem *currPeeledInst;
    IR_ITEM_VALUE loopLabel;
    IR_ITEM_VALUE peeledLabel;

    /* Get the first instruction from each list. */
    currLoopInst = xanList_first(loopInsts);
    firstLoop = xanList_getData(currLoopInst);
    currPeeledInst = xanList_first(peeledInsts);
    firstPeeled = xanList_getData(currPeeledInst);

    /* Get the label of the first peeled instruction. */
    loopLabel = IRMETHOD_getInstructionParameter1Value(firstLoop);
    peeledLabel = IRMETHOD_getInstructionParameter1Value(firstPeeled);

    /* Patch up each non-loop, non-peeled predecessor of the loop. */
    pred = NULL;
    while ((pred = IRMETHOD_getPredecessorInstruction(method, firstLoop, pred))) {
        if (!xanList_find(loopInsts, pred) &&
                !xanList_find(peeledInsts, pred)) {

            /* If it's a branch to the loop, patch the label up. */
            if (pred->type == IRBRANCH) {
                assert(IRMETHOD_getInstructionParameter1Value(pred) == loopLabel);
                IRMETHOD_setInstructionParameter1Value(method, pred, peeledLabel);
            }

            /* Also patch up if target of conditional branch. */
            else if ((pred->type == IRBRANCHIF || pred->type == IRBRANCHIFNOT) &&
                     IRMETHOD_getInstructionParameter2Value(pred) == loopLabel) {
                IRMETHOD_setInstructionParameter2Value(method, pred, peeledLabel);
            }

            /* Otherwise it's a fall-through so move all peeled instructions. */
            else {
                ir_instruction_t *afterInst = pred;
                currPeeledInst = xanList_first(peeledInsts);
                while (currPeeledInst) {
                    ir_instruction_t *inst;
                    inst = xanList_getData(currPeeledInst);
                    IRMETHOD_moveInstructionAfter(method, inst, afterInst);
                    afterInst = inst;
                    currPeeledInst = currPeeledInst->next;
                }
            }
        }
    }
}

/**
 * Add successor loop instructions of an instruction to a worklist following
 * the fall-through edges of the control flow graph.
 */
static inline void addFallThroughInstsToList(ir_method_t *method, XanList *loopInsts, XanList *instList, ir_instruction_t *inst) {
    ir_instruction_t *instToAdd;

    /* Repeat until no more instructions are added. */
    instToAdd = inst;
    while (instToAdd) {
        ir_instruction_t *succ;

        /* Only direct branches shouldn't be followed. */
        if (IRMETHOD_getSuccessorsNumber(method, inst) == 1) {
            if (inst->type != IRBRANCH) {

                /* Add this successor and repeat. */
                succ = IRMETHOD_getSuccessorInstruction(method, inst, NULL);
                instToAdd = succ;
                inst = succ;
            } else {
                instToAdd = NULL;
            }
        }

        /* Check we're following fall-through edges. */
        else if (IRMETHOD_getSuccessorsNumber(method, inst) == 2) {
            ir_instruction_t *fall;
            IR_ITEM_VALUE targetLabel;

            /* This must be some kind of branch. */
            assert(inst->type == IRBRANCHIF || inst->type == IRBRANCHIFNOT);

            /* Get the target label. */
            targetLabel = IRMETHOD_getInstructionParameter2Value(inst);

            /* Check the successor labels to find the fall-through edge. */
            succ = fall = NULL;
            while (!fall &&
                    (succ = IRMETHOD_getSuccessorInstruction(method, inst, succ))) {

                /* No label or label mis-match must be the fall-through. */
                if (succ->type != IRLABEL ||
                        IRMETHOD_getInstructionParameter1Value(succ) != targetLabel) {
                    fall = succ;
                }
            }

            /* Add this fall-through instruction. */
            instToAdd = fall;
            inst = fall;
        }

        /* Do any instructions have >2 successors? */
        else {
            PDEBUG("Instruction %u in method %s has >2 successors.\n", inst->ID, IRMETHOD_getSignatureInString(method));
            assert(JITFALSE);
        }

        /* Add the instruction, possibly. */
        if (instToAdd) {
            if (!xanList_find(instList, instToAdd) &&
                    xanList_find(loopInsts, instToAdd)) {
                xanList_append(instList, instToAdd);
            } else {
                instToAdd = NULL;
            }
        }
    }
}

/**
 * Check a branch to see if it leaves a loop.  If it does, add the target
 * label to the list of out-of-loop labels.  If the target instruction is not
 * a label, create a new label before it.
 */
static inline void getBranchOutLabels(ir_method_t *method, ir_instruction_t *inst, XanList *loopInsts, XanList *outLabels) {
    ir_instruction_t *succ = NULL;

    /* Add labels of non-loop successors. */
    while ((succ = IRMETHOD_getSuccessorInstruction(method, inst, succ))) {
        if (!xanList_find(loopInsts, succ)) {
            if (succ->type == IRLABEL) {
                ir_item_t *param = IRMETHOD_getInstructionParameter1(succ);
                xanList_append(outLabels, createValuePtr(param->value.v));
            }

            /* Branch to non-label instruction (fall-through). */
            else {
                ir_instruction_t *labelInst;
                IR_ITEM_VALUE labelValue;

                /* Create a new label. */
                labelValue = IRMETHOD_newLabelID(method);
                labelInst = IRMETHOD_newInstructionBefore(method, succ);
                IRMETHOD_setInstructionType(method, labelInst, IRLABEL);
                IRMETHOD_setInstructionParameter1(method, labelInst, labelValue, 0.0, IRLABELITEM, IRLABELITEM, NULL);

                /* Store it. */
                xanList_append(outLabels, createValuePtr(labelValue));
            }
        }
    }
}

/**
 * Fix up cloned branch instructions so that their targets are correct.  If
 * the branch falls through to a non-loop instruction then invert the cloned
 * branch and alter the target label.
 */
static inline void fixClonedBranch(ir_method_t *method, ir_instruction_t *inst, ir_instruction_t *clone, XanList *loopInsts) {
    ir_instruction_t *succ;

    /* A check on this instruction. */
    assert(inst->type == IRBRANCHIF || inst->type ==  IRBRANCHIFNOT);

    /* Check if the branch falls through to a non-loop instruction. */
    succ = NULL;
    while ((succ = IRMETHOD_getSuccessorInstruction(method, inst, succ))) {
        if (!xanList_find(loopInsts, succ)) {

            /* Check if this is the fall-through edge. */
            assert(succ->type == IRLABEL);
            if (IRMETHOD_getInstructionParameter1Value(succ) != IRMETHOD_getInstructionParameter2Value(inst)) {

                /* Invert the cloned branch and fix the label. */
                if (clone->type == IRBRANCHIF) {
                    IRMETHOD_setInstructionType(method, clone, IRBRANCHIFNOT);
                } else {
                    IRMETHOD_setInstructionType(method, clone, IRBRANCHIF);
                }
                IRMETHOD_setInstructionParameter2Value(method, clone, IRMETHOD_getInstructionParameter1Value(succ));
            }
        }
    }
}

/**
 * Translate one label into another.  If a mapping exists in the label map
 * then use that.  Otherwise, create a new label and store the mapping for
 * later use, as long as the old label isn't to be ignored.
 */
static inline void translateLabel(ir_method_t *method, ir_item_t *label, XanHashTable *labelMap, XanList *ignoreLabels) {
    IR_ITEM_VALUE *mapping;

    /* See if there's an existing mapping. */
    mapping = xanHashTable_lookup(labelMap, &label->value);

    /* Alter the label. */
    if (mapping) {
        label->value.v = *mapping;
    } else if (ignoreLabels && !inLabelList(ignoreLabels, label->value.v)) {
        IR_ITEM_VALUE *key = createValuePtr(label->value.v);
        label->value.v = IRMETHOD_newLabelID(method);
        xanHashTable_insert(labelMap, key, createValuePtr(label->value.v));
    }
}

/**
 * Create a pointer to a parameter value for use in lists and tables.
 */
static inline void * createValuePtr(IR_ITEM_VALUE val) {
    IR_ITEM_VALUE *ptr = malloc(sizeof(IR_ITEM_VALUE));
    *ptr = val;
    return ptr;
}

/**
 * Create a hash of a value pointer parameter.
 */
static inline JITUINT32 valuePtrHash(void *element) {
    IR_ITEM_VALUE val = *(IR_ITEM_VALUE *)element;
    return ((val >> 32) | (val & 0xffffffff));
}

/**
 * Check whether two parameter value pointers match.
 */
static inline JITINT32  valuePtrsMatch(void *key1, void *key2) {
    return (*(IR_ITEM_VALUE *)key1 == *(IR_ITEM_VALUE *)key2);
}

/**
 * Check whether a list of parameter value pointers contains a parameter value.
 */
static inline JITBOOLEAN inLabelList(XanList *labels, IR_ITEM_VALUE value) {
    XanListItem *item;
    item = xanList_first(labels);
    while (item) {
        IR_ITEM_VALUE *check = xanList_getData(item);
        if (*check == value) {
            return JITTRUE;
        }
        item = item->next;
    }
    return JITFALSE;
}
